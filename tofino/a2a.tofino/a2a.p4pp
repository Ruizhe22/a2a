# 1 "a2a.p4"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 10 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "a2a.p4" 2
/* -*- P4_16 -*- */
# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */




/// Standard error codes.  New error codes can be declared by users.
error {
    NoError, /// No error.
    PacketTooShort, /// Not enough bits in packet for 'extract'.
    NoMatch, /// 'select' expression has no matches.
    StackOutOfBounds, /// Reference to invalid element of a header stack.
    HeaderTooShort, /// Extracting too many bits into a varbit field.
    ParserTimeout, /// Parser execution time limit exceeded.
    ParserInvalidArgument /// Parser operation was called with a value
                           /// not supported by the implementation.
}

extern packet_in {
    /// Read a header from the packet into a fixed-sized header @hdr and advance the cursor.
    /// May trigger error PacketTooShort or StackOutOfBounds.
    /// @T must be a fixed-size header type
    void extract<T>(out T hdr);
    /// Read bits from the packet into a variable-sized header @variableSizeHeader
    /// and advance the cursor.
    /// @T must be a header containing exactly 1 varbit field.
    /// May trigger errors PacketTooShort, StackOutOfBounds, or HeaderTooShort.
    void extract<T>(out T variableSizeHeader,
                    in bit<32> variableFieldSizeInBits);
    /// Read bits from the packet without advancing the cursor.
    /// @returns: the bits read from the packet.
    /// T may be an arbitrary fixed-size type.
    T lookahead<T>();
    /// Advance the packet cursor by the specified number of bits.
    void advance(in bit<32> sizeInBits);
    /// @return packet length in bytes.  This method may be unavailable on
    /// some target architectures.
    bit<32> length();
}

extern packet_out {
    /// Write @hdr into the output packet, advancing cursor.
    /// @T can be a header type, a header stack, a header_union, or a struct
    /// containing fields with such types.
    void emit<T>(in T hdr);
}

// TODO: remove from this file, convert to built-in
/// Check a predicate @check in the parser; if the predicate is true do nothing,
/// otherwise set the parser error to @toSignal, and transition to the `reject` state.
extern void verify(in bool check, in error toSignal);

/// Built-in action that does nothing.
@noWarn("unused")
action NoAction() {}

/// Standard match kinds for table key fields.
/// Some architectures may not support all these match kinds.
/// Architectures can declare additional match kinds.
match_kind {
    /// Match bits exactly.
    exact,
    /// Ternary match, using a mask.
    ternary,
    /// Longest-prefix match.
    lpm
}

/// Static assert evaluates a boolean expression
/// at compilation time.  If the expression evaluates to
/// false, compilation is stopped and the corresponding message is printed.
/// The function returns a boolean, so that it can be used
/// as a global constant value in a program, e.g.:
/// const bool _check = static_assert(V1MODEL_VERSION > 20180000, "Expected a v1 model version >= 20180000");
extern bool static_assert(bool check, string message);

/// Like the above but using a default message.
extern bool static_assert(bool check);
# 3 "a2a.p4" 2
# 1 "/usr/local/share/p4c/p4include/tna.p4" 1
/**
 * Copyright (C) 2024 Intel Corporation
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * 
 * SPDX-License-Identifier: Apache-2.0
 */






# 1 "/usr/local/share/p4c/p4include/tofino1_specs.p4" 1
/**
 * Copyright (C) 2024 Intel Corporation
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * 
 * SPDX-License-Identifier: Apache-2.0
 */





/**
 Version Notes:

 2.0.1:
 - Restructuralize P4 header files (tna.p4 -> tofino1_specs.p4 + tofino1_base.p4 + tofino1_arch.p4)
   - tna.p4                : Top-level header file to be included by P4 programs, includes the below
     -> tofino1_specs.p4   : Target-device-specific types, constants and macros
     -> tofino1_arch.p4    : Portable parsers, controls and packages (originally tofino1arch.p4)
        -> tofino1_base.p4 : Portable constants, headers, externs etc. (originally tofino.p4)

*/



// ----------------------------------------------------------------------------
// COMMON TYPES
// ----------------------------------------------------------------------------

@noWarn("unused")
typedef bit<9> PortId_t; // Port id -- ingress or egress port

@noWarn("unused")
typedef bit<16> MulticastGroupId_t; // Multicast group id

@noWarn("unused")
typedef bit<5> QueueId_t; // Queue id

@noWarn("unused")
typedef bit<3> MirrorType_t; // Mirror type

@noWarn("unused")
typedef bit<10> MirrorId_t; // Mirror id

@noWarn("unused")
typedef bit<3> ResubmitType_t; // Resubmit type

@noWarn("unused")
typedef bit<3> DigestType_t; // Digest type

@noWarn("unused")
typedef bit<16> ReplicationId_t; // Replication id

@noWarn("unused")
typedef bit<16> L1ExclusionId_t; // L1 Exclusion id

@noWarn("unused")
typedef bit<9> L2ExclusionId_t; // L2 Exclusion id

@noWarn("unused")
typedef error ParserError_t;


@noWarn("unused")
const bit<32> PORT_METADATA_SIZE = 32w64;
# 25 "/usr/local/share/p4c/p4include/tna.p4" 2






# 1 "/usr/local/share/p4c/p4include/tofino1_arch.p4" 1
/**
 * Copyright (C) 2024 Intel Corporation
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * 
 * SPDX-License-Identifier: Apache-2.0
 */





/**
 Version Notes:

 2.0.1:
 - Restructuralize P4 header files (tna.p4 -> tofino1_specs.p4 + tofino1_base.p4 + tofino1_arch.p4)
   - tna.p4                : Top-level header file to be included by P4 programs, includes the below
     -> tofino1_specs.p4   : Target-device-specific types, constants and macros
     -> tofino1_arch.p4    : Portable parsers, controls and packages (originally tofino1arch.p4)
        -> tofino1_base.p4 : Portable constants, headers, externs etc. (originally tofino.p4)

*/

# 1 "/usr/local/share/p4c/p4include/tofino1_base.p4" 1
/**
 * Copyright (C) 2024 Intel Corporation
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * 
 * SPDX-License-Identifier: Apache-2.0
 */





/**
 Version Notes:

 1.0.1:
 - Initial release
 1.0.2:
 - Rename PARSER_ERROR_NO_TCAM to PARSER_ERROR_NO_MATCH
 1.0.3:
 - Add portable macros and types
 2.0.1:
 - Restructuralize P4 header files (tna.p4 -> tofino1_specs.p4 + tofino1_base.p4 + tofino1_arch.p4)
   - tna.p4                : Top-level header file to be included by P4 programs, includes the below
     -> tofino1_specs.p4   : Target-device-specific types, constants and macros
     -> tofino1_arch.p4    : Portable parsers, controls and packages (originally tofino1arch.p4)
        -> tofino1_base.p4 : Portable constants, headers, externs etc. (originally tofino.p4)

*/






@noWarn("unused")
const bit<16> PARSER_ERROR_OK = 16w0x0000;
@noWarn("unused")
const bit<16> PARSER_ERROR_NO_MATCH = 16w0x0001;
@noWarn("unused")
const bit<16> PARSER_ERROR_PARTIAL_HDR = 16w0x0002;
@noWarn("unused")
const bit<16> PARSER_ERROR_CTR_RANGE = 16w0x0004;
@noWarn("unused")
const bit<16> PARSER_ERROR_TIMEOUT_USER = 16w0x0008;
@noWarn("unused")
const bit<16> PARSER_ERROR_TIMEOUT_HW = 16w0x0010;
@noWarn("unused")
const bit<16> PARSER_ERROR_SRC_EXT = 16w0x0020;
@noWarn("unused")
const bit<16> PARSER_ERROR_DST_CONT = 16w0x0040;
@noWarn("unused")
const bit<16> PARSER_ERROR_PHV_OWNER = 16w0x0080;
@noWarn("unused")
const bit<16> PARSER_ERROR_MULTIWRITE = 16w0x0100;
@noWarn("unused")
const bit<16> PARSER_ERROR_ARAM_MBE = 16w0x0400;
@noWarn("unused")
const bit<16> PARSER_ERROR_FCS = 16w0x0800;

/// Meter
enum MeterType_t { PACKETS, BYTES }

enum bit<8> MeterColor_t { GREEN = 8w0, YELLOW = 8w1, RED = 8w3 }

/// Counter
enum CounterType_t {
    PACKETS,
    BYTES,
    PACKETS_AND_BYTES
}

/// Selector mode
enum SelectorMode_t { FAIR, RESILIENT }

enum HashAlgorithm_t {
    IDENTITY,
    RANDOM,
    XOR8,
    XOR16,
    XOR32,
    CRC8,
    CRC16,
    CRC32,
    CRC64,
    CUSTOM /*< custom CRC polynomial - see the CRCPolynomial extern */
}

match_kind {
    // exact,
    // ternary,
    // lpm,               // Longest-prefix match.
    range,
    selector, // Used for implementing dynamic action selection
    atcam_partition_index // Used for implementing algorithmic tcam
}

error {
    // NoError,           // No error.
    // NoMatch,           // 'select' expression has no matches.
    // PacketTooShort,    // Not enough bits in packet for 'extract'.
    // StackOutOfBounds,  // Reference to invalid element of a header stack.
    // HeaderTooShort,    // Extracting too many bits into a varbit field.
    // ParserTimeout      // Parser execution time limit exceeded.
    CounterRange, // Counter initialization error.
    Timeout,
    PhvOwner, // Invalid destination container.
    MultiWrite,
    IbufOverflow, // Input buffer overflow.
    IbufUnderflow // Inbut buffer underflow.
}

// -----------------------------------------------------------------------------
// INGRESS INTRINSIC METADATA
// -----------------------------------------------------------------------------
@__intrinsic_metadata
header ingress_intrinsic_metadata_t {
    bit<1> resubmit_flag; // Flag distinguishing original packets
                                        // from resubmitted packets.
    @padding bit<1> _pad1;

    bit<2> packet_version; // Read-only Packet version.

    @padding bit<(4 - 9 % 8)> _pad2;

    PortId_t ingress_port; // Ingress physical port id.

    bit<48> ingress_mac_tstamp; // Ingress IEEE 1588 timestamp (in nsec)
                                        // taken at the ingress MAC.
}

@__intrinsic_metadata
struct ingress_intrinsic_metadata_for_tm_t {
    PortId_t ucast_egress_port; // Egress port for unicast packets. must
                                        // be presented to TM for unicast.

    bit<1> bypass_egress; // Request flag for the warp mode
                                        // (egress bypass).

    bit<1> deflect_on_drop; // Request for deflect on drop. must be
                                        // presented to TM to enable deflection
                                        // upon drop.

    bit<3> ingress_cos; // Ingress cos (iCoS) for PG mapping,
                                        // ingress admission control, PFC,
                                        // etc.

    QueueId_t qid; // Egress (logical) queue id into which
                                        // this packet will be deposited.

    bit<3> icos_for_copy_to_cpu; // Ingress cos for the copy to CPU. must
                                        // be presented to TM if copy_to_cpu ==
                                        // 1.

    bit<1> copy_to_cpu; // Request for copy to cpu.

    bit<2> packet_color; // Packet color (G,Y,R) that is
                                        // typically derived from meters and
                                        // used for color-based tail dropping.

    bit<1> disable_ucast_cutthru; // Disable cut-through forwarding for
                                        // unicast.

    bit<1> enable_mcast_cutthru; // Enable cut-through forwarding for
                                        // multicast.

    MulticastGroupId_t mcast_grp_a; // 1st multicast group (i.e., tree) id;
                                        // a tree can have two levels. must be
                                        // presented to TM for multicast.

    MulticastGroupId_t mcast_grp_b; // 2nd multicast group (i.e., tree) id;
                                        // a tree can have two levels.

    bit<13> level1_mcast_hash; // Source of entropy for multicast
                                        // replication-tree level1 (i.e., L3
                                        // replication). must be presented to TM
                                        // for L3 dynamic member selection
                                        // (e.g., ECMP) for multicast.

    bit<13> level2_mcast_hash; // Source of entropy for multicast
                                        // replication-tree level2 (i.e., L2
                                        // replication). must be presented to TM
                                        // for L2 dynamic member selection
                                        // (e.g., LAG) for nested multicast.

    L1ExclusionId_t level1_exclusion_id; // Exclusion id for multicast
                                        // replication-tree level1. used for
                                        // pruning.

    L2ExclusionId_t level2_exclusion_id; // Exclusion id for multicast
                                        // replication-tree level2. used for
                                        // pruning.

    bit<16> rid; // L3 replication id for multicast.
}

@__intrinsic_metadata
struct ingress_intrinsic_metadata_from_parser_t {
    bit<48> global_tstamp; // Global timestamp (ns) taken upon
                                        // arrival at ingress.

    bit<32> global_ver; // Global version number taken upon
                                        // arrival at ingress.

    bit<16> parser_err; // Error flags indicating error(s)
                                        // encountered at ingress parser.
}

@__intrinsic_metadata
struct ingress_intrinsic_metadata_for_deparser_t {

    bit<3> drop_ctl; // Disable packet replication:
                                        //    - bit 0 disables unicast,
                                        //      multicast, and resubmit
                                        //    - bit 1 disables copy-to-cpu
                                        //    - bit 2 reserved
    DigestType_t digest_type;

    ResubmitType_t resubmit_type;

    MirrorType_t mirror_type; // The user-selected mirror field list
                                        // index.
}

// -----------------------------------------------------------------------------
// EGRESS INTRINSIC METADATA
// -----------------------------------------------------------------------------
@__intrinsic_metadata
header egress_intrinsic_metadata_t {
    @padding bit<(8 - 9 % 8)> _pad0;

    PortId_t egress_port; // Egress port id.
                                        // this field is passed to the deparser

    @padding bit<5> _pad1;

    bit<19> enq_qdepth; // Queue depth at the packet enqueue
                                        // time.

    @padding bit<6> _pad2;

    bit<2> enq_congest_stat; // Queue congestion status at the packet
                                        // enqueue time.

    @padding bit<14> _pad3;
    bit<18> enq_tstamp; // Time snapshot taken when the packet
                                        // is enqueued (in nsec).

    @padding bit<5> _pad4;

    bit<19> deq_qdepth; // Queue depth at the packet dequeue
                                        // time.

    @padding bit<6> _pad5;

    bit<2> deq_congest_stat; // Queue congestion status at the packet
                                        // dequeue time.

    bit<8> app_pool_congest_stat; // Dequeue-time application-pool
                                        // congestion status. 2bits per
                                        // pool.

    @padding bit<14> _pad6;
    bit<18> deq_timedelta; // Time delta between the packet's
                                        // enqueue and dequeue time.

    bit<16> egress_rid; // L3 replication id for multicast
                                        // packets.

    @padding bit<7> _pad7;

    bit<1> egress_rid_first; // Flag indicating the first replica for
                                        // the given multicast group.

    @padding bit<(8 - 5 % 8)> _pad8;

    QueueId_t egress_qid; // Egress (physical) queue id via which
                                        // this packet was served.

    @padding bit<5> _pad9;

    bit<3> egress_cos; // Egress cos (eCoS) value.

    @padding bit<7> _pad10;

    bit<1> deflection_flag; // Flag indicating whether a packet is
                                        // deflected due to deflect_on_drop.

    bit<16> pkt_length; // Packet length, in bytes
}

@__intrinsic_metadata
struct egress_intrinsic_metadata_from_parser_t {
    bit<48> global_tstamp; // Global timestamp (ns) taken upon
                                        // arrival at egress.

    bit<32> global_ver; // Global version number taken upon
                                        // arrival at ingress.

    bit<16> parser_err; // Error flags indicating error(s)
                                        // encountered at ingress parser.
}

@__intrinsic_metadata
struct egress_intrinsic_metadata_for_deparser_t {
    bit<3> drop_ctl; // Disable packet replication:
                                        //    - bit 0 disables unicast,
                                        //      multicast, and resubmit
                                        //    - bit 1 disables copy-to-cpu
                                        //    - bit 2 disables mirroring

    MirrorType_t mirror_type;

    bit<1> coalesce_flush; // Flush the coalesced mirror buffer

    bit<7> coalesce_length; // The number of bytes in the current
                                        // packet to collect in the mirror
                                        // buffer
}

@__intrinsic_metadata
struct egress_intrinsic_metadata_for_output_port_t {
    bit<1> capture_tstamp_on_tx; // Request for packet departure
                                        // timestamping at egress MAC for IEEE
                                        // 1588. consumed by h/w (egress MAC).

    bit<1> update_delay_on_tx; // Request for PTP delay (elapsed time)
                                        // update at egress MAC for IEEE 1588
                                        // Transparent Clock. consumed by h/w
                                        // (egress MAC). when this is enabled,
                                        // the egress pipeline must prepend a
                                        // custom header composed of <ingress
                                        // tstamp (40), byte offset for the
                                        // elapsed time field (8), byte offset
                                        // for UDP checksum (8)> in front of the
                                        // Ethernet header.
}

// -----------------------------------------------------------------------------
// PACKET GENERATION
// -----------------------------------------------------------------------------
// Packet generator supports up to 8 applications and a total of 16KB packet
// payload. Each application is associated with one of the four trigger types:
// - One-time timer
// - Periodic timer
// - Port down
// - Packet recirculation
// For recirculated packets, the event fires when the first 32 bits of the
// recirculated packet matches the application match value and mask.
// A triggered event may generate programmable number of batches with
// programmable number of packets per batch.
header pktgen_timer_header_t {
    @padding bit<3> _pad1;
    bit<2> pipe_id; // Pipe id
    bit<3> app_id; // Application id
    @padding bit<8> _pad2;

    bit<16> batch_id; // Start at 0 and increment to a
                                        // programmed number

    bit<16> packet_id; // Start at 0 and increment to a
                                        // programmed number
}

header pktgen_port_down_header_t {
    @padding bit<3> _pad1;
    bit<2> pipe_id; // Pipe id
    bit<3> app_id; // Application id
    @padding bit<(16 - 9 % 8)> _pad2;
    PortId_t port_num; // Port number

    bit<16> packet_id; // Start at 0 and increment to a
                                        // programmed number
}

header pktgen_recirc_header_t {
    @padding bit<3> _pad1;
    bit<2> pipe_id; // Pipe id
    bit<3> app_id; // Application id
    bit<24> key; // Key from the recirculated packet

    bit<16> packet_id; // Start at 0 and increment to a
                                        // programmed number
}

// -----------------------------------------------------------------------------
// TIME SYNCHRONIZATION
// -----------------------------------------------------------------------------

header ptp_metadata_t {
    bit<8> udp_cksum_byte_offset; // Byte offset at which the egress MAC
                                        // needs to update the UDP checksum


    bit<8> cf_byte_offset; // Byte offset at which the egress MAC
                                        // needs to re-insert
                                        // ptp_sync.correction field

    bit<48> updated_cf; // Updated correction field in ptp sync
                                        // message
}

// -----------------------------------------------------------------------------
// CHECKSUM
// -----------------------------------------------------------------------------
// Tofino checksum engine can verify the checksums for header-only checksums
// and calculate the residual (checksum minus the header field
// contribution) for checksums that include the payload.
// Checksum engine only supports 16-bit ones' complement checksums, also known
// as csum16 or internet checksum.

extern Checksum {
    /// Constructor.
    Checksum();

    /// Add data to checksum.
    /// @param data : List of fields to be added to checksum calculation. The
    /// data must be byte aligned.
    void add<T>(in T data);

    /// Subtract data from existing checksum.
    /// @param data : List of fields to be subtracted from the checksum. The
    /// data must be byte aligned.
    void subtract<T>(in T data);

    /// Verify whether the complemented sum is zero, i.e. the checksum is valid.
    /// @return : Boolean flag indicating whether the checksum is valid or not.
    bool verify();

    /// Subtract all header fields after the call and
    /// return the calculated checksum value.
    /// Marks the end position for residual checksum header.
    /// All header fields extracted after the call will be automatically
    /// subtracted.
    /// @param residual: The calculated checksum value for added fields.
    void subtract_all_and_deposit<T>(out T residual);

    /// Get the calculated checksum value.
    /// @return : The calculated checksum value for added fields.
    bit<16> get();

    /// Calculate the checksum for a  given list of fields.
    /// @param data : List of fields contributing to the checksum value.
    /// @param zeros_as_ones : encode all-zeros value as all-ones.
    bit<16> update<T>(in T data, @optional in bool zeros_as_ones);
}

// ----------------------------------------------------------------------------
// PARSER COUNTER
// ----------------------------------------------------------------------------
// Tofino parser counter can be used to extract header stacks or headers with
// variable length. Tofino has a single 8-bit signed counter that can be
// initialized with an immediate value or a header field.

extern ParserCounter {
    /// Constructor
    ParserCounter();

    /// Load the counter with an immediate value or a header field.
    void set<T>(in T value);

    /// Load the counter with a header field.
    /// @param max : Maximum permitted value for counter (pre rotate/mask/add).
    /// @param rotate : Right rotate (circular) the source field by this number of bits.
    /// @param mask : Mask the rotated source field by 2 ^ (mask + 1) - 1.
    /// @param add : Constant to add to the rotated and masked lookup field.
    void set<T>(in T field,
                in bit<8> max,
                in bit<8> rotate,
                in bit<3> mask,
                in bit<8> add);

    /// @return true if counter value is zero.
    bool is_zero();

    /// @return true if counter value is negative.
    bool is_negative();

    /// Add an immediate value to the parser counter.
    /// @param value : Constant to add to the counter.
    void increment(in bit<8> value);

    /// Subtract an immediate value from the parser counter.
    /// @param value : Constant to subtract from the counter.
    void decrement(in bit<8> value);
}

// ----------------------------------------------------------------------------
// PARSER PRIORITY
// ----------------------------------------------------------------------------
// Tofino ingress parser compare the priority with a configurable!!! threshold
// to determine to whether drop the packet if the input buffer is congested.
// Egress parser does not perform any dropping.

extern ParserPriority {
    /// Constructor
    ParserPriority();

    /// Set a new priority for the packet.
    /// param prio : parser priority for the parsed packet.
    void set(in bit<3> prio);
}

// ----------------------------------------------------------------------------
// HASH ENGINE
// ----------------------------------------------------------------------------
extern CRCPolynomial<T> {
    CRCPolynomial(T coeff, bool reversed, bool msb, bool extended, T init, T xor);
}

extern Hash<W> {
    /// Constructor
    /// @type_param W : width of the calculated hash.
    /// @param algo : The default algorithm used for hash calculation.
    Hash(HashAlgorithm_t algo);

    /// Constructor
    /// @param poly : The default coefficient used for hash algorithm.
    Hash(HashAlgorithm_t algo, CRCPolynomial<_> poly);

    /// Compute the hash for the given data.
    /// @param data : The list of fields contributing to the hash.
    /// @return The hash value.
    W get<D>(in D data);
}

/// Random number generator.
extern Random<W> {
    /// Constructor
    /// @type_param W : width of the calculated hash.
    Random();

    /// Return a random number with uniform distribution.
    /// @return : random number between 0 and 2**W - 1
    W get();
}

// -----------------------------------------------------------------------------
// EXTERN FUNCTIONS
// -----------------------------------------------------------------------------

extern T max<T>(in T t1, in T t2);

extern T min<T>(in T t1, in T t2);

extern void funnel_shift_right<T>(inout T dst, in T src1, in T src2, int shift_amount);

extern void invalidate<T>(in T field);

extern bool is_validated<T>(in T field);

/// Phase0
extern T port_metadata_unpack<T>(packet_in pkt);

extern bit<32> sizeInBits<H>(in H h);

extern bit<32> sizeInBytes<H>(in H h);

/// Counter
/// Indexed counter with `size’ independent counter values.
@noWarn("unused")
extern Counter<W, I> {
    /// Constructor
    /// @type_param W : width of the counter value.
    /// @type_param I : width of the counter index.
    /// @param type : counter type. Packet an byte counters are supported.
    Counter(bit<32> size, CounterType_t type);

    /// Increment the counter value.
    /// @param index : index of the counter to be incremented.
    /// @param adjust_byte_count : optional parameter indicating value to be
    //                             subtracted from counter value.
    void count(in I index, @optional in bit<32> adjust_byte_count);
}

/// DirectCounter
@noWarn("unused")
extern DirectCounter<W> {
    DirectCounter(CounterType_t type);
    void count(@optional in bit<32> adjust_byte_count);
}

/// Meter
extern Meter<I> {
    Meter(bit<32> size, MeterType_t type);
    Meter(bit<32> size, MeterType_t type, bit<8> red, bit<8> yellow, bit<8> green);
    bit<8> execute(in I index, in MeterColor_t color, @optional in bit<32> adjust_byte_count);
    bit<8> execute(in I index, @optional in bit<32> adjust_byte_count);
}

/// Direct meter.
extern DirectMeter {
    DirectMeter(MeterType_t type);
    DirectMeter(MeterType_t type, bit<8> red, bit<8> yellow, bit<8> green);
    bit<8> execute(in MeterColor_t color, @optional in bit<32> adjust_byte_count);
    bit<8> execute(@optional in bit<32> adjust_byte_count);
}

/// LPF
extern Lpf<T, I> {
    Lpf(bit<32> size);
    T execute(in T val, in I index);
}

/// Direct LPF
extern DirectLpf<T> {
    DirectLpf();
    T execute(in T val);
}

/// WRED
extern Wred<T, I> {
    Wred(bit<32> size, bit<8> drop_value, bit<8> no_drop_value);
    bit<8> execute(in T val, in I index);
}

/// Direct WRED
extern DirectWred<T> {
    DirectWred(bit<8> drop_value, bit<8> no_drop_value);
    bit<8> execute(in T val);
}

/// Register
extern Register<T, I> {
    /// Instantiate an array of <size> registers. The initial value is
    /// undefined.
    Register(bit<32> size);

    /// Initialize an array of <size> registers and set their value to
    /// initial_value.
    Register(bit<32> size, T initial_value);

    /// Return the value of register at specified index.
    T read(in I index);

    /// Write value to register at specified index.
    T write(in I index, in T value);
}

/// DirectRegister
extern DirectRegister<T> {
    /// Instantiate an array of direct registers. The initial value is
    /// undefined.
    DirectRegister();

    /// Initialize an array of direct registers and set their value to
    /// initial_value.
    DirectRegister(T initial_value);

    /// Return the value of the direct register.
    T read();

    /// Write value to a direct register.
    T write(in T value);
}

extern RegisterParam<T> {
    /// Construct a read-only run-time configurable parameter that can only be
    /// used by RegisterAction.
    /// @param initial_value : initial value of the parameter.
    RegisterParam(T initial_value);

    /// Return the value of the parameter.
    T read();
}

enum MathOp_t {
    MUL, // 2^scale * f(x)         --  false,  0
    SQR, // 2^scale * f(x^2)       --  false,  1
    SQRT, // 2^scale * f(sqrt(x))   --  false, -1
    DIV, // 2^scale * f(1/x)       --  true,   0
    RSQR, // 2^scale * f(1/x^2)     --  true,   1
    RSQRT // 2^scale * f(1/sqrt(x)) --  true,  -1
};

extern MathUnit<T> {
    /// Configure a math unit for use in a register action
    MathUnit(bool invert, int<2> shift, int<6> scale,
             // Note: data tuple contains values in order from 15..0 (reversed)
             tuple< bit<8>, bit<8>, bit<8>, bit<8>,
                    bit<8>, bit<8>, bit<8>, bit<8>,
                    bit<8>, bit<8>, bit<8>, bit<8>,
                    bit<8>, bit<8>, bit<8>, bit<8> > data);
    MathUnit(MathOp_t op, int factor); // configure as factor * op(x)
    MathUnit(MathOp_t op, int A, int B); // configure as (A/B) * op(x)
    T execute(in T x);
};

// This is implemented using an experimental feature in p4c and subject to
// change. See https://github.com/p4lang/p4-spec/issues/561
@noWarn("unused")
extern RegisterAction<T, I, U> {
    RegisterAction(Register<_, _> reg);

    U execute(in I index); /* {
        U rv;
        T value = reg.read(index);
        apply(value, rv);
        reg.write(index, value);
        return rv;
    } */
    // Apply the implemented abstract method using an index that increments each
    // time. This method is useful for stateful logging.
    U execute_log();

    // Abstract method that needs to be implemented when RegisterAction is
    // instantiated.
    // @param value : register value.
    // @param rv : return value.
    @synchronous(execute, execute_log)
    abstract void apply(inout T value, @optional out U rv);

    U predicate(@optional in bool cmplo,
                @optional in bool cmphi); /* return the 4-bit predicate value */
}

extern DirectRegisterAction<T, U> {
    DirectRegisterAction(DirectRegister<T> reg);

    U execute(); /* {
        U rv;
        T value = reg.read();
        apply(value, rv);
        reg.write(value);
        return rv;
    } */

    // Abstract method that needs to be implemented when RegisterAction is
    // instantiated.
    // @param value : register value.
    // @param rv : return value.
    @synchronous(execute)
    abstract void apply(inout T value, @optional out U rv);

    U predicate(@optional in bool cmplo,
                @optional in bool cmphi); /* return the 4-bit predicate value */
}

extern ActionProfile {
    /// Construct an action profile of 'size' entries.
    ActionProfile(bit<32> size);
}

extern ActionSelector {
    /// Construct a selection table for a given ActionProfile.
    ActionSelector(ActionProfile action_profile,
                   Hash<_> hash,
                   SelectorMode_t mode,
                   bit<32> max_group_size,
                   bit<32> num_groups);

    /// Stateful action selector.
    ActionSelector(ActionProfile action_profile,
                   Hash<_> hash,
                   SelectorMode_t mode,
                   Register<bit<1>, _> reg,
                   bit<32> max_group_size,
                   bit<32> num_groups);

    /// Construct a selection table for action profile of 'size' entries.
    @deprecated("ActionSelector must be specified with an associated ActionProfile")
    ActionSelector(bit<32> size, Hash<_> hash, SelectorMode_t mode);

    @deprecated("ActionSelector must be specified with an associated ActionProfile")
    ActionSelector(bit<32> size, Hash<_> hash, SelectorMode_t mode, Register<bit<1>, _> reg);
}

extern SelectorAction {
    SelectorAction(ActionSelector sel);
    bit<1> execute(@optional in bit<32> index);
    @synchronous(execute)
    abstract void apply(inout bit<1> value, @optional out bit<1> rv);
}

// Tofino supports mirroring both at the ingress and egress. Ingress deparser
// creates a copy of the original ingress packet and prepends the mirror header.
// Egress deparser first constructs the output packet and then prepends the
// mirror header.
extern Mirror {
    /// Constructor
    @deprecated("Mirror must be specified with the value of the mirror_type instrinsic metadata")
    Mirror();

    /// Constructor
    Mirror(MirrorType_t mirror_type);

    /// Mirror the packet.
    void emit(in MirrorId_t session_id);

    /// Write @hdr into the ingress/egress mirror buffer.
    /// @param hdr : T can be a header type.
    void emit<T>(in MirrorId_t session_id, in T hdr);
}

// Tofino supports packet resubmission at the end of ingress pipeline. When
// a packet is resubmitted, the original packet reference and some limited
// amount of metadata (64 bits) are passed back to the packet’s original
// ingress buffer, where the packet is enqueued again.
extern Resubmit {
    /// Constructor
    @deprecated("Resubmit must be specified with the value of the resubmit_type instrinsic metadata")
    Resubmit();

    /// Constructor
    Resubmit(ResubmitType_t resubmit_type);

    /// Resubmit the packet.
    void emit();

    /// Resubmit the packet and prepend it with @hdr.
    /// @param hdr : T can be a header type.
    void emit<T>(in T hdr);
}

extern Digest<T> {
    /// define a digest stream to the control plane
    @deprecated("Digest must be specified with the value of the digest_type instrinsic metadata")
    Digest();

    /// constructor.
    Digest(DigestType_t digest_type);

    /// Emit data into the stream.  The p4 program can instantiate multiple
    /// Digest instances in the same deparser control block, and call the pack
    /// method once during a single execution of the control block
    void pack(in T data);
}

// Algorithmic TCAM.
// Specify the implementation of a table to be algorithmic TCAM by providing an
// instance of the extern to the 'implementation' attribute of the table.  User
// must also specify one of the table keys with 'atcam_partition_index'
// match_kind.
extern Atcam {
    /// define the parameters for ATCAM table.
    Atcam(@optional bit<32> number_partitions);
}

// Algorithmic LPM.
// Specify the implementation of a table to be algorithmic LPM by providing an
// instance of the extern to the 'implementation' attribute of the table.
extern Alpm {
    /// define the parameters for ALPM table.
    Alpm(@optional bit<32> number_partitions, @optional bit<32> subtrees_per_partition,
         @optional bit<32> atcam_subset_width, @optional bit<32> shift_granularity);
}
# 36 "/usr/local/share/p4c/p4include/tofino1_arch.p4" 2

// The following declarations provide a template for the programmable blocks in
// Tofino.

parser IngressParserT<H, M>(
    packet_in pkt,
    out H hdr,
    out M ig_md,
    @optional out ingress_intrinsic_metadata_t ig_intr_md,
    @optional out ingress_intrinsic_metadata_for_tm_t ig_intr_md_for_tm,
    @optional out ingress_intrinsic_metadata_from_parser_t ig_intr_md_from_prsr);

parser EgressParserT<H, M>(
    packet_in pkt,
    out H hdr,
    out M eg_md,
    @optional out egress_intrinsic_metadata_t eg_intr_md,
    @optional out egress_intrinsic_metadata_from_parser_t eg_intr_md_from_prsr,
    @optional out egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr);

control IngressT<H, M>(
    inout H hdr,
    inout M ig_md,
    @optional in ingress_intrinsic_metadata_t ig_intr_md,
    @optional in ingress_intrinsic_metadata_from_parser_t ig_intr_md_from_prsr,
    @optional inout ingress_intrinsic_metadata_for_deparser_t ig_intr_md_for_dprsr,
    @optional inout ingress_intrinsic_metadata_for_tm_t ig_intr_md_for_tm);

control EgressT<H, M>(
    inout H hdr,
    inout M eg_md,
    @optional in egress_intrinsic_metadata_t eg_intr_md,
    @optional in egress_intrinsic_metadata_from_parser_t eg_intr_md_from_prsr,
    @optional inout egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr,
    @optional inout egress_intrinsic_metadata_for_output_port_t eg_intr_md_for_oport);

control IngressDeparserT<H, M>(
    packet_out pkt,
    inout H hdr,
    in M metadata,
    @optional in ingress_intrinsic_metadata_for_deparser_t ig_intr_md_for_dprsr,
    @optional in ingress_intrinsic_metadata_t ig_intr_md);

control EgressDeparserT<H, M>(
    packet_out pkt,
    inout H hdr,
    in M metadata,
    @optional in egress_intrinsic_metadata_for_deparser_t eg_intr_md_for_dprsr,
    @optional in egress_intrinsic_metadata_t eg_intr_md,
    @optional in egress_intrinsic_metadata_from_parser_t eg_intr_md_from_prsr);

package Pipeline<IH, IM, EH, EM>(
    IngressParserT<IH, IM> ingress_parser,
    IngressT<IH, IM> ingress,
    IngressDeparserT<IH, IM> ingress_deparser,
    EgressParserT<EH, EM> egress_parser,
    EgressT<EH, EM> egress,
    EgressDeparserT<EH, EM> egress_deparser);

@pkginfo(arch="TNA", version="2.0.1")
@noWarn("unused")
package Switch<IH0, IM0, EH0, EM0, IH1, IM1, EH1, EM1,
               IH2, IM2, EH2, EM2, IH3, IM3, EH3, EM3>(
    Pipeline<IH0, IM0, EH0, EM0> pipe0,
    @optional Pipeline<IH1, IM1, EH1, EM1> pipe1,
    @optional Pipeline<IH2, IM2, EH2, EM2> pipe2,
    @optional Pipeline<IH3, IM3, EH3, EM3> pipe3);

package IngressParsers<H, M>(
    IngressParserT<H, M> prsr0,
    @optional IngressParserT<H, M> prsr1,
    @optional IngressParserT<H, M> prsr2,
    @optional IngressParserT<H, M> prsr3,
    @optional IngressParserT<H, M> prsr4,
    @optional IngressParserT<H, M> prsr5,
    @optional IngressParserT<H, M> prsr6,
    @optional IngressParserT<H, M> prsr7,
    @optional IngressParserT<H, M> prsr8,
    @optional IngressParserT<H, M> prsr9,
    @optional IngressParserT<H, M> prsr10,
    @optional IngressParserT<H, M> prsr11,
    @optional IngressParserT<H, M> prsr12,
    @optional IngressParserT<H, M> prsr13,
    @optional IngressParserT<H, M> prsr14,
    @optional IngressParserT<H, M> prsr15,
    @optional IngressParserT<H, M> prsr16,
    @optional IngressParserT<H, M> prsr17);

package EgressParsers<H, M>(
    EgressParserT<H, M> prsr0,
    @optional EgressParserT<H, M> prsr1,
    @optional EgressParserT<H, M> prsr2,
    @optional EgressParserT<H, M> prsr3,
    @optional EgressParserT<H, M> prsr4,
    @optional EgressParserT<H, M> prsr5,
    @optional EgressParserT<H, M> prsr6,
    @optional EgressParserT<H, M> prsr7,
    @optional EgressParserT<H, M> prsr8,
    @optional EgressParserT<H, M> prsr9,
    @optional EgressParserT<H, M> prsr10,
    @optional EgressParserT<H, M> prsr11,
    @optional EgressParserT<H, M> prsr12,
    @optional EgressParserT<H, M> prsr13,
    @optional EgressParserT<H, M> prsr14,
    @optional EgressParserT<H, M> prsr15,
    @optional EgressParserT<H, M> prsr16,
    @optional EgressParserT<H, M> prsr17);

package MultiParserPipeline<IH, IM, EH, EM>(
    IngressParsers<IH, IM> ig_prsr,
    IngressT<IH, IM> ingress,
    IngressDeparserT<IH, IM> ingress_deparser,
    EgressParsers<EH, EM> eg_prsr,
    EgressT<EH, EM> egress,
    EgressDeparserT<EH, EM> egress_deparser);

@pkginfo(arch="TNA", version="2.0.1")
@noWarn("unused")
package MultiParserSwitch<IH0, IM0, EH0, EM0, IH1, IM1, EH1, EM1,
                          IH2, IM2, EH2, EM2, IH3, IM3, EH3, EM3>(
    MultiParserPipeline<IH0, IM0, EH0, EM0> pipe0,
    @optional MultiParserPipeline<IH1, IM1, EH1, EM1> pipe1,
    @optional MultiParserPipeline<IH2, IM2, EH2, EM2> pipe2,
    @optional MultiParserPipeline<IH3, IM3, EH3, EM3> pipe3);
# 32 "/usr/local/share/p4c/p4include/tna.p4" 2
# 4 "a2a.p4" 2

# 1 "./a2a_types.p4" 1
# 1 "./std_types.p4" 1
typedef bit<48> mac_addr_t;
typedef bit<32> ipv4_addr_t;

typedef bit<16> ether_type_t;
const ether_type_t ETHERTYPE_IPV4 = 16w0x0800;

typedef bit<8> ip_protocol_t;
const ip_protocol_t IP_PROTOCOLS_TCP = 6;
const ip_protocol_t IP_PROTOCOLS_UDP = 17;

const bit<16> UDP_PORT_ROCE = 4791;

const bit<8> RDMA_OP_SEND_FIRST = 8w0x00;
const bit<8> RDMA_OP_SEND_MIDDLE = 8w0x01;
const bit<8> RDMA_OP_SEND_LAST = 8w0x02;
const bit<8> RDMA_OP_SEND_LAST_WITH_IMM = 8w0x03;
const bit<8> RDMA_OP_SEND_ONLY = 8w0x04;
const bit<8> RDMA_OP_SEND_ONLY_WITH_IMM = 8w0x05;
const bit<8> RDMA_OP_WRITE_FIRST = 8w0x06;
const bit<8> RDMA_OP_WRITE_MIDDLE = 8w0x07;
const bit<8> RDMA_OP_WRITE_LAST = 8w0x08;
const bit<8> RDMA_OP_WRITE_LAST_WITH_IMM = 8w0x09;
const bit<8> RDMA_OP_WRITE_ONLY = 8w0x0a; // WRITE_ONLY occurs when the message is shorter than RDMA_MTU
const bit<8> RDMA_OP_WRITE_ONLY_WITH_IMM = 8w0x0b;
const bit<8> RDMA_OP_READ_REQ = 8w0x0c;
const bit<8> RDMA_OP_READ_RES_FIRST = 8w0x0d;
const bit<8> RDMA_OP_READ_RES_MIDDLE = 8w0x0e;
const bit<8> RDMA_OP_READ_RES_LAST = 8w0x0f;
const bit<8> RDMA_OP_READ_RES_ONLY = 8w0x10;
const bit<8> RDMA_OP_ACK = 8w0x11;
const bit<8> RDMA_OP_ATOMIC_ACK = 8w0x12;
const bit<8> RDMA_OP_CMPSWAP = 8w0x13;
const bit<8> RDMA_OP_FETCHADD = 8w0x14;
const bit<8> RDMA_OP_CNP = 8w0x81;
const bit<8> RDMA_OP_UD_SEND_ONLY = 8w0x64;

header eth_h {
    mac_addr_t dst_addr;
    mac_addr_t src_addr;
    bit<16> ether_type;
}

header ipv4_h {
    bit<8> ver_ihl; // version, ihl, 4 + 4
    bit<8> diffserv;
    bit<16> total_len;
    bit<16> identification;
    bit<16> flag_offset; // flag, frag_offset, 3 + 13
    bit<8> ttl;
    bit<8> protocol;
    bit<16> hdr_checksum;
    ipv4_addr_t src_addr;
    ipv4_addr_t dst_addr;
}

header tcp_h {
    bit<16> src_port;
    bit<16> dst_port;
    bit<32> seq_no;
    bit<32> ack_no;
    bit<8> data_offset_res; // data_offset , res, 4 + 4
    bit<8> flags;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgent_ptr;
}

header udp_h {
    bit<16> src_port;
    bit<16> dst_port;
    bit<16> length;
    bit<16> checksum;
}


header bth_h {
    bit<8> opcode;
    bit<8> se_migreq_pad_ver; // se = Solicited Event, ver = Transport Header Version, 1 + 1 + 2 + 4
    bit<16> pkey; // Partition Key, like VLAN id, 1 bit permission + 15 bit key 
    //bit<8> f_b_rsv; // FECN, BECN, reserved(0), 1 + 1 + 6, FECN may be useless in ROCEv2?
    bit<32> dst_qp; // f_b_rsv, dest QPN, 8 + 24
    // bit<8> ackreq_rsv; // the ACK for this packet should be scheduled by the responder, 1 + 7 
    // bit<24> seq_num;// responder is able to send ACK and can decide whether to send ACK.
    bit<32> psn; // ackreq_rsv + psn, 24
}

header reth_h {
    bit<64> addr; // virtual address
    bit<32> rkey;
    bit<32> len; // DMA length, padding bytes is not included
}

// --- ACK Syndrome Values ---

const bit<32> AETH_ACK_CREDIT_INVALID = 32w0x1F; // Binary: 000 11111 (Op:00, Credit:31/Invalid)
const bit<32> AETH_ACK_CREDIT_ZERO = 32w0x00; // Binary: 000 00000 (Op:00, Credit:0)

// --- NAK Syndrome Values (OpCode: 11) --- Binary: 011 NNNNN
const bit<32> AETH_NAK_SEQ_ERR = 32w0x60; // NAK Code 0: PSN Sequence Error
const bit<32> AETH_NAK_INV_REQ = 32w0x61; // NAK Code 1: Invalid Request
const bit<32> AETH_NAK_R_ACC_ERR = 32w0x62; // NAK Code 2: Remote Access Error

header aeth_h {
     // 1 bit 0 + 2 bit flag [6:5] (ACK, RNR NAK, reserved, NAK) + 5 bit number (credit cnt, RNR timer, N/A, NAK code)
    bit<32> msn; // syndrom, 24 bit message sequence number, start from 0
}

header atomic_eth_h {
    bit<64> addr;
    bit<32> rkey;
    bit<64> swapadd_data;
    bit<64> compare_data;
}

header atomic_aeth_h {
    bit<64> original_data;
}

header cnp_h {
    bit<128> reserved;
}

header imm_h {
    bit<32> imm;
}

/* in dispatch, for tx, epsn is the next psn to switch,
 *              for rx, epsn is the next psn to rx
 */
typedef bit<32> init_epsn_t;
typedef bit<64> init_addr_t;


header icrc_h {
    bit<8> v0;
    bit<8> v1;
    bit<8> v2;
    bit<8> v3;
}
# 2 "./a2a_types.p4" 2


// @pa_container_size("ingress", "hdr.payload.data00", 32)
// @pa_container_size("ingress", "hdr.payload.data01", 32)
// @pa_container_size("ingress", "hdr.payload.data02", 32)
// @pa_container_size("ingress", "hdr.payload.data03", 32)
// @pa_container_size("ingress", "hdr.payload.data04", 32)
// @pa_container_size("ingress", "hdr.payload.data05", 32)
// @pa_container_size("ingress", "hdr.payload.data06", 32)
// @pa_container_size("ingress", "hdr.payload.data07", 32)
// @pa_container_size("ingress", "hdr.payload.data08", 32)
// @pa_container_size("ingress", "hdr.payload.data09", 32)
// @pa_container_size("ingress", "hdr.payload.data0a", 32)
// @pa_container_size("ingress", "hdr.payload.data0b", 32)
// @pa_container_size("ingress", "hdr.payload.data0c", 32)
// @pa_container_size("ingress", "hdr.payload.data0d", 32)
// @pa_container_size("ingress", "hdr.payload.data0e", 32)
// @pa_container_size("ingress", "hdr.payload.data0f", 32)
// @pa_container_size("ingress", "hdr.payload.data10", 32)
// @pa_container_size("ingress", "hdr.payload.data11", 32)
// @pa_container_size("ingress", "hdr.payload.data12", 32)
// @pa_container_size("ingress", "hdr.payload.data13", 32)
// @pa_container_size("ingress", "hdr.payload.data14", 32)
// @pa_container_size("ingress", "hdr.payload.data15", 32)
// @pa_container_size("ingress", "hdr.payload.data16", 32)
// @pa_container_size("ingress", "hdr.payload.data17", 32)








typedef bit<32> bitmap_tofino_t;

enum bit<2> CONN_PHASE {
    CONN_DISPATCH = 1,
    CONN_COMBINE = 2,
    CONN_UNKNOWN = 0
}

enum bit<2> CONN_SEMANTICS {
    CONN_CONTROL = 0,
    CONN_TX = 1,
    CONN_RX = 2,
    CONN_BITMAP = 3 // only for combine
}

// partial payload size which can be processed by tofino stages while remaining payload is in the real packet payload
header payload_h {
    bit<32> data00;
    bit<32> data01;
    bit<32> data02;
    bit<32> data03;
    bit<32> data04;
    bit<32> data05;
    bit<32> data06;
    bit<32> data07;
    bit<32> data08;
    bit<32> data09;
    bit<32> data0a;
    bit<32> data0b;
    bit<32> data0c;
    bit<32> data0d;
    bit<32> data0e;
    bit<32> data0f;
    bit<32> data10;
    bit<32> data11;
    bit<32> data12;
    bit<32> data13;
    bit<32> data14;
    bit<32> data15;
    bit<32> data16;
    bit<32> data17;
}

header payload_word_h {
    bit<32> data;
}



header bridge_h {
    // dispatch or combine 8bytes
    bit<32> ing_rank_id;
    bool has_reth;
    bool has_aeth;
    bool has_payload;
    CONN_PHASE conn_phase;
    CONN_SEMANTICS conn_semantics;
    bit<32> channel_id;
    bitmap_tofino_t bitmap;
    // combine only, 5bytes
    bit<32> tx_loc_val;
    bit<32> tx_offset_val;
    bit<32> clear_offset;
    bool is_loopback;
    bit<32> root_rank_id;
    // 8
    bit<64> next_token_addr;
}

struct a2a_headers_t {
    bridge_h bridge;
    eth_h eth;
    ipv4_h ipv4;
    udp_h udp;
    bth_h bth;
    aeth_h aeth;
    reth_h reth;
    payload_word_h payload_first_word;
    payload_h payload;
    icrc_h icrc;
}


struct bridge_t {
    // dispatch or combine 8bytes
    // @pa_no_pack("ingress", "ig_md.bridge.ing_rank_id")
    bit<32> ing_rank_id;
    // @pa_no_pack("ingress", "ig_md.bridge.has_reth")
    bool has_reth;
    // @pa_no_pack("ingress", "ig_md.bridge.has_aeth")
    bool has_aeth;
    // @pa_no_pack("ingress", "ig_md.bridge.has_payload")
    bool has_payload;
    // @pa_no_pack("ingress", "ig_md.bridge.conn_phase")
    CONN_PHASE conn_phase;
    // @pa_no_pack("ingress", "ig_md.bridge.conn_semantics")  
    CONN_SEMANTICS conn_semantics;
    //@pa_no_pack("ingress", "ig_md.bridge.channel_id")
    bit<32> channel_id;
    // @pa_no_pack("ingress", "ig_md.bridge.bitmap")
    bitmap_tofino_t bitmap;
    // @pa_no_pack("ingress", "ig_md.bridge.tx_loc_val")
    // combine only, 5bytes
    bit<32> tx_loc_val;
    // @pa_no_pack("ingress", "ig_md.bridge.tx_offset_val")
    bit<32> tx_offset_val;
    // @pa_no_pack("ingress", "ig_md.bridge.clear_offset")
    bit<32> clear_offset;
    // @pa_no_pack("ingress", "ig_md.bridge.is_loopback")
    bool is_loopback;
    // @pa_no_pack("ingress", "ig_md.bridge.root_rank_id")
    bit<32> root_rank_id;
    // @pa_no_pack("ingress", "ig_md.bridge.next_token_addr")
    // 8
    bit<64> next_token_addr;
}



struct a2a_ingress_metadata_t {
    bool is_roce;
    bitmap_tofino_t bitmap_clear_mask;
    //@pa_container_size("ingress", "ig_md.psn", 32)
    //@pa_no_overlay("ingress", "ig_md.psn")
    bit<32> psn;
    bit<32> msn;
    bit<32> syndrome;
    bit<32> channel_class;
    bit<32> token_idx;
    bit<32> slot_index;
    //@pa_container_size("ingress", "ig_md.expected_epsn", 32)
    //@pa_no_overlay("ingress", "ig_md.expected_epsn")
    bit<32> expected_epsn;
    //@pa_container_size("ingress", "ig_md.msn_saved", 32)
    //@pa_no_overlay("ingress", "ig_md.msn_saved")
    bit<32> msn_saved;
    //@pa_container_size("ingress", "ig_md.psn_to_check", 32)
    //@pa_no_overlay("ingress", "ig_md.psn_to_check")
    bit<32> psn_to_check;
    //@pa_container_size("ingress", "ig_md.temp_queue_data", 32)
    bit<32> temp_queue_data;
    //@pa_container_size("ingress", "ig_md.next_loc", 32)
    bit<32> next_loc;
    bridge_t bridge;
}

struct a2a_egress_metadata_t {
    bit<32> psn;
    bit<32> eg_rank_id;
    bridge_t bridge;
}

/* Although the bitmap is defined to be 64 bits, we only use lower 32 bits in practice
 * as the total number of ports in tofino is limited to 32 in current design.
 */
struct bitmap_t {
    bit<32> lo;
    bit<32> hi;
}

typedef bit<64> addr_tofino_t;
typedef bit<32> addr_half_t ;



enum bit<2> DISPATCH_REG_OP {
    OP_INIT = 0,
    OP_READ_INC = 1,
    OP_READ_ADD = 2
}

enum bit<2> COMBINE_QUEUE_POINTER_REG_OP {
    OP_INIT = 0,
    OP_READ = 1,
    OP_INC = 2,
    OP_READ_ADD = 3 // read and add a fixed value 8 (circular)
}

enum bit<2> COMBINE_BITMAP_REG_OP {
    OP_READ = 1,
    OP_WRITE = 2,
    OP_CLEAR_BIT = 3, // XOR clear specified bit(s), return value after clear
    OP_RESET = 0 // reset to 0
}

enum bit<2> COMBINE_ADDR_REG_OP {
    OP_RESET = 0,
    OP_READ = 1,
    OP_WRITE = 2
}
# 6 "a2a.p4" 2
# 1 "./dispatch_control.p4" 1
/* EP_SIZE(N) 8 */



/***************************************************************************
 * Dispatch Ingress Control
 * addr of the next hop should be set in egress pipeline, 
 * depending on the channel_id and the egress port.
 ***************************************************************************/

control DispatchIngress(
    inout a2a_headers_t hdr,
    inout a2a_ingress_metadata_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)
{

    /***************************************************************************
     * Registers
     ***************************************************************************/

    /* tx_epsn */
    Register<bit<32>, bit<32>>((8 * 8)) reg_tx_epsn;

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_epsn) ra_read_cond_inc_tx_epsn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            if (ig_md.psn_to_check == value) {
                value = value + 1;
            }
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_epsn) ra_init_tx_epsn = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_epsn) ra_invalidate_tx_epsn = {
        void apply(inout bit<32> value) {
            value = 0xFFFFFFFF;
        }
    };

    /* tx_msn */
    Register<bit<32>, bit<32>>((8 * 8)) reg_tx_msn;

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_msn) ra_read_tx_msn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_msn) ra_inc_tx_msn = {
        void apply(inout bit<32> value) {
            value = value + 1;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_msn) ra_init_tx_msn = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    /* tx_bitmap */


    Register<bitmap_tofino_t, bit<32>>((8 * 8)) reg_tx_bitmap;

    RegisterAction<bitmap_tofino_t, bit<32>, bitmap_tofino_t>(reg_tx_bitmap) ra_read_tx_bitmap = {
        void apply(inout bitmap_tofino_t value, out bitmap_tofino_t result) {
            result = value;
        }
    };

    RegisterAction<bitmap_tofino_t, bit<32>, void>(reg_tx_bitmap) ra_write_tx_bitmap = {
        void apply(inout bitmap_tofino_t value) {
            value = ig_md.bridge.bitmap;
        }
    };

    /***************************************************************************
     * Utility Actions
     ***************************************************************************/

    // action set_ack_ingress(bit<32> syndrome, bit<32> psn, bit<32> msn) {
    //     hdr.bth.psn = psn;
    //     hdr.aeth.setValid();
    //     hdr.aeth.msn = msn<<8 | (bit<32>)syndrome;
    // }

    bit<32> tmp_mul_256;

    action mul_256(){
        tmp_mul_256 = tmp_mul_256 * 256;
    }

    action set_aeth_msn() {
        ig_md.bridge.has_aeth = true;
        hdr.aeth.setValid();
        hdr.aeth.msn = tmp_mul_256 * 256;
    }

    action set_aeth_syndrome(bit<32> syndrome) {
        hdr.aeth.msn = hdr.aeth.msn + syndrome;
    }

    action set_aeth_psn(bit<32> psn) {
        hdr.bth.psn = psn; // If there's an ack header (e.g., RDMA_OP_ACK or Read response), PSN is determined by the ack, set here

    }

    /***************************************************************************
     * Apply
     ***************************************************************************/

    apply {

        bit<32> channel_idx = (bit<32>)ig_md.bridge.channel_id;
        // process ACK/NAK from rx
        if (ig_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_RX && hdr.bth.opcode == RDMA_OP_ACK) {
            if (ig_md.syndrome > 32) {
                ra_invalidate_tx_epsn.execute(channel_idx);
            }
            ig_dprsr_md.drop_ctl = 1;
            return;
        }

        // process control connection
        if (ig_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_CONTROL) {
            ra_init_tx_msn.execute(channel_idx);
            // should be extract from payload, but we set 0 as an agreement with the endpoint
            ra_init_tx_epsn.execute(channel_idx);
            //set_ack_ingress(AETH_ACK_CREDIT_INVALID, ig_md.psn, ig_md.psn+1);
            tmp_mul_256 = ig_md.psn+1;
            mul_256();
            set_aeth_msn();
            set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
            set_aeth_psn(ig_md.psn);
            ig_md.bridge.has_aeth = true;
            ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
            //ig_intr_md_for_dprsr.drop_ctl = 1;
            //ig_tm_md.mirror_session_id = ig_md.ing_rank_id;
            return;
        }

        // process data from tx
        if (ig_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_TX) {
            if (hdr.bth.opcode != RDMA_OP_WRITE_FIRST &&
                hdr.bth.opcode != RDMA_OP_WRITE_MIDDLE &&
                hdr.bth.opcode != RDMA_OP_WRITE_LAST &&
                hdr.bth.opcode != RDMA_OP_WRITE_ONLY) {
                ig_dprsr_md.drop_ctl = 1;
                return;
            }

            // PSN validation
            ig_md.psn_to_check = ig_md.psn;

            ig_md.expected_epsn = ra_read_cond_inc_tx_epsn.execute(channel_idx);
            ig_md.msn_saved = ra_read_tx_msn.execute(channel_idx);
            if(ig_md.psn > ig_md.expected_epsn) {
                //set_ack_ingress(AETH_NAK_SEQ_ERR, ig_md.expected_epsn-1, ig_md.msn_saved);
                tmp_mul_256 = ig_md.msn_saved;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_NAK_SEQ_ERR);
                set_aeth_psn(ig_md.expected_epsn-1);
                ig_md.bridge.has_aeth = true;
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
                //ig_intr_md_for_dprsr.drop_ctl = 1;
                //ig_tm_md.mirror_session_id = ig_md.ing_rank_id;
                return;
            } else if(ig_md.psn < ig_md.expected_epsn){
                //set_ack_ingress(AETH_ACK_CREDIT_INVALID, ig_md.expected_epsn-1, ig_md.msn_saved);
                tmp_mul_256 = ig_md.msn_saved;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
                set_aeth_psn(ig_md.expected_epsn-1);
                ig_md.bridge.has_aeth = true;
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
                return;
            }

            // fetch bitmap
            if (hdr.bth.opcode == RDMA_OP_WRITE_FIRST ||
                hdr.bth.opcode == RDMA_OP_WRITE_ONLY) {
                ig_md.bridge.bitmap = hdr.reth.addr[31:0]; // 32ports in tofino
                ra_write_tx_bitmap.execute(channel_idx);
            } else {
                ig_md.bridge.bitmap = ra_read_tx_bitmap.execute(channel_idx);
            }

            // multicast group
            ig_tm_md.mcast_grp_a = 100; // group id 100 is to all ports

            // ACK to ingress port
            //set_ack_ingress(AETH_ACK_CREDIT_INVALID, ig_md.expected_epsn-1, ig_md.msn_saved);
            tmp_mul_256 = ig_md.msn_saved;
            mul_256();
            set_aeth_msn();
            set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
            set_aeth_psn(ig_md.expected_epsn-1);
            ig_md.bridge.has_aeth = true;
            ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
            // MSN
            if (hdr.bth.opcode == RDMA_OP_WRITE_ONLY ||
                hdr.bth.opcode == RDMA_OP_WRITE_LAST) {
                ra_inc_tx_msn.execute(channel_idx);
            }
        }
    }
}


/***************************************************************************
 * Dispatch Egress Control
 * Bridge header: 
    header bridge_h {
        bool is_roce;
        bool has_reth;
        bool has_aeth;
        bool has_payload;
        CONN_PHASE  conn_phase;    // dispatch or combine
        CONN_SEMANTICS conn_semantics;
        bit<32>    channel_id;
        bitmap_tofino_t    bitmap;
    }
 ***************************************************************************/


/*******************************************************************************
 * RxPsnSlot - PSN management for a single RX
 ******************************************************************************/
control RxPsnSlot(
    out bit<32> result_psn,
    in bit<32> init_value,
    in DISPATCH_REG_OP operation,
    in bit<32> channel_idx)
{
    bit<32> init_val;

    Register<bit<32>, bit<32>>((8 * 8)) reg_psn;

    RegisterAction<bit<32>, bit<32>, void>(reg_psn) ra_init = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_psn) ra_read_inc = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            value = value + 1;
        }
    };

    apply {
        if (operation == DISPATCH_REG_OP.OP_INIT) {
            init_val = init_value;
            ra_init.execute(channel_idx);
        } else if (operation == DISPATCH_REG_OP.OP_READ_INC) {
            result_psn = ra_read_inc.execute(channel_idx);
        }
    }
}

/*******************************************************************************
 * RxAddrSlot - Address management for a single RX
 ******************************************************************************/
control RxAddrSlot(
    out addr_tofino_t result_addr,
    in addr_tofino_t init_addr,
    in bit<32> add_value,
    in DISPATCH_REG_OP operation,
    in bit<32> channel_idx)
{

    bit<32> add_val;

    // ==================== Low 32 bits ====================
    Register<bit<32>, bit<32>>(8) reg_addr_lo;

    // init lo
    RegisterAction<bit<32>, bit<32>, void>(reg_addr_lo) ra_lo_init = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    // read and add lo, return 1 if overflow (for carry)
    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_addr_lo) ra_lo_read_add = {
        void apply(inout bit<32> value, out bit<32> res) {
            res = value;
            value = value + add_val;
        }
    };

    // ==================== High 32 bits ====================
    Register<bit<32>, bit<32>>(8) reg_addr_hi;

    // init hi
    RegisterAction<bit<32>, bit<32>, void>(reg_addr_hi) ra_hi_init = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    // read hi (no add since add_value is 32-bit, only affects lo)
    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_addr_hi) ra_hi_read = {
        void apply(inout bit<32> value, out bit<32> res) {
            res = value;
        }
    };

    apply {
        if (operation == DISPATCH_REG_OP.OP_INIT) {
            ra_lo_init.execute(channel_idx);
            ra_hi_init.execute(channel_idx);

        } else if (operation == DISPATCH_REG_OP.OP_READ_ADD) {
            add_val = add_value;
            result_addr[31:0] = ra_lo_read_add.execute(channel_idx);
            result_addr[63:32] = ra_hi_read.execute(channel_idx);
        }
    }
}

/*******************************************************************************
 * DispatchEgress
 ******************************************************************************/
control DispatchEgress(
    inout a2a_headers_t hdr,
    inout a2a_egress_metadata_t eg_md,
    in egress_intrinsic_metadata_t eg_intr_md,
    inout egress_intrinsic_metadata_for_deparser_t eg_dprsr_md)
{
    /***************************************************************************
     * PSN Slot Instances (EP_SIZE = 8)
     ***************************************************************************/
    RxPsnSlot() psn_slot_0;
    RxPsnSlot() psn_slot_1;
    RxPsnSlot() psn_slot_2;
    RxPsnSlot() psn_slot_3;
    RxPsnSlot() psn_slot_4;
    RxPsnSlot() psn_slot_5;
    RxPsnSlot() psn_slot_6;
    RxPsnSlot() psn_slot_7;

    /***************************************************************************
     * Addr Slot Instances (EP_SIZE = 8)
     ***************************************************************************/
    RxAddrSlot() addr_slot_0;
    RxAddrSlot() addr_slot_1;
    RxAddrSlot() addr_slot_2;
    RxAddrSlot() addr_slot_3;
    RxAddrSlot() addr_slot_4;
    RxAddrSlot() addr_slot_5;
    RxAddrSlot() addr_slot_6;
    RxAddrSlot() addr_slot_7;

    /***************************************************************************
     * Local Variables
     ***************************************************************************/
    bit<32> channel_idx;
    bit<32> result_psn;
    bit<64> result_addr;
    bit<32> payload_len_32;

    /***************************************************************************
     * Table - Set RX info based on egress_rid
     **************************************************************************/
    action get_rank_id(bit<32> rank_id) {
        eg_md.eg_rank_id = rank_id;
    }

    table dispatch_rank_info {
        key = {
            eg_md.bridge.channel_id : exact;
            eg_intr_md.egress_port : exact;
        }
        actions = {
            get_rank_id;
            NoAction;
        }
        size = 1024;
        default_action = NoAction;
    }


    action set_rx_info(bit<48> dst_mac, bit<32> dst_ip,
                       bit<32> dst_qp, bit<32> rkey) {

        hdr.eth.dst_addr = dst_mac;
        hdr.ipv4.dst_addr = dst_ip;
        hdr.bth.dst_qp = dst_qp;
        hdr.reth.rkey = rkey;
    }

    table dispatch_rx_info {
        key = {
            eg_md.bridge.channel_id : exact;
            eg_md.eg_rank_id : exact;
        }
        actions = {
            set_rx_info;
            NoAction;
        }
        size = 1024;
        default_action = NoAction;
    }

    /***************************************************************************
     * Apply
     ***************************************************************************/
    action set_ack_egress() {
        // Remove unnecessary headers
        hdr.reth.setInvalid();
        hdr.payload.setInvalid();

        // BTH
        hdr.bth.opcode = RDMA_OP_ACK;

        // UDP
        hdr.udp.length = 28;
        bit<16> tmp_port = hdr.udp.src_port;
        hdr.udp.src_port = hdr.udp.dst_port;
        hdr.udp.dst_port = tmp_port;
        hdr.udp.checksum = 0;

        // IPv4
        hdr.ipv4.total_len = 48;
        bit<32> tmp_ip = hdr.ipv4.src_addr;
        hdr.ipv4.src_addr = hdr.ipv4.dst_addr;
        hdr.ipv4.dst_addr = tmp_ip;

        // Ethernet
        bit<48> tmp_mac = hdr.eth.src_addr;
        hdr.eth.src_addr = hdr.eth.dst_addr;
        hdr.eth.dst_addr = tmp_mac;
    }

    apply {

        dispatch_rank_info.apply();
        channel_idx = (bit<32>)eg_md.bridge.channel_id;

        // ==================== Control connection: initialize all RX ====================
        if (eg_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_CONTROL) {

            // Initialize PSN (payload: data00 - data07)
            // psn_slot_0.apply(result_psn, hdr.payload.data00, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_1.apply(result_psn, hdr.payload.data01, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_2.apply(result_psn, hdr.payload.data02, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_3.apply(result_psn, hdr.payload.data03, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_4.apply(result_psn, hdr.payload.data04, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_5.apply(result_psn, hdr.payload.data05, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_6.apply(result_psn, hdr.payload.data06, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // psn_slot_7.apply(result_psn, hdr.payload.data07, DISPATCH_REG_OP.OP_INIT, channel_idx);

            // // Initialize Addr (payload: data08-data17, each address 64-bit = lo + hi)
            // // addr_tofino_t structure: {lo, hi}
            // addr_slot_0.apply(result_addr,
            //                   hdr.payload.data08, hdr.payload.data09,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_1.apply(result_addr,
            //                   hdr.payload.data0a, hdr.payload.data0b,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_2.apply(result_addr,
            //                   hdr.payload.data0c, hdr.payload.data0d,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_3.apply(result_addr,
            //                   hdr.payload.data0e, hdr.payload.data0f,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_4.apply(result_addr,
            //                   hdr.payload.data10, hdr.payload.data11,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_5.apply(result_addr,
            //                   hdr.payload.data12, hdr.payload.data13,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_6.apply(result_addr,
            //                   hdr.payload.data14, hdr.payload.data15,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);
            // addr_slot_7.apply(result_addr,
            //                   hdr.payload.data16, hdr.payload.data17,
            //                   0, DISPATCH_REG_OP.OP_INIT, channel_idx);

            set_ack_egress();

            return;
        }

        // ==================== Data connection: Multicast replica processing ====================
        if (eg_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_TX) {
            if((eg_intr_md.egress_rid == 0)&&(eg_md.bridge.ing_rank_id == eg_md.eg_rank_id)) {
                set_ack_egress();
            }
            else if(((eg_md.bridge.bitmap >> eg_md.eg_rank_id) & 1) == 1){
                // Bcast packet to all replicas
                payload_len_32 = 1024; // to add addr
                // Lookup and set RX info based on egress_rid
                dispatch_rx_info.apply();

                // ===== PSN: select corresponding slot based on rank_id =====
                if (eg_md.eg_rank_id == 0) {
                    psn_slot_0.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 1) {
                    psn_slot_1.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 2) {
                    psn_slot_2.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 3) {
                    psn_slot_3.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 4) {
                    psn_slot_4.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 5) {
                    psn_slot_5.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 6) {
                    psn_slot_6.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                } else if (eg_md.eg_rank_id == 7) {
                    psn_slot_7.apply(result_psn, 0, DISPATCH_REG_OP.OP_READ_INC, channel_idx);
                }

                // Update BTH PSN
                hdr.bth.psn = result_psn;

                // ===== Addr: only update when RETH is valid =====
                if (hdr.reth.isValid() &&
                    (hdr.bth.opcode == RDMA_OP_WRITE_FIRST ||
                    hdr.bth.opcode == RDMA_OP_WRITE_ONLY)) {
                    if (eg_md.eg_rank_id == 0) {
                        addr_slot_0.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 1) {
                        addr_slot_1.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 2) {
                        addr_slot_2.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 3) {
                        addr_slot_3.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 4) {
                        addr_slot_4.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 5) {
                        addr_slot_5.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 6) {
                        addr_slot_6.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    } else if (eg_md.eg_rank_id == 7) {
                        addr_slot_7.apply(result_addr, 0,
                                        payload_len_32, DISPATCH_REG_OP.OP_READ_ADD, channel_idx);
                    }

                    // Update RETH addr (addr_tofino_t: lo first, hi second)
                    hdr.reth.addr = result_addr;
                }

                hdr.aeth.setInvalid();
            }
            else {
                eg_dprsr_md.drop_ctl = 1;
            }
        }
    }
}
# 7 "a2a.p4" 2
# 1 "./combine_control.p4" 1
/*******************************************************************************
 * Combine Control for AllToAll Communication - In-Network Aggregation
 * 
 * Aggregate the first 4 bytes of each packet
 * 
 * Connection types:
 * - CONN_CONTROL: query queue pointer (READ)
 * - CONN_BITMAP: rx writes bitmap (WRITE)
 * - CONN_TX: tx writes token for aggregation (WRITE)
 * - CONN_RX: rx reads aggregation result (READ)
 * 
 * Data structures:
 * - tx_epsn[j]: expected PSN from j-th tx
 * - tx_msn[j]: MSN of j-th tx
 * - tx_loc[j]: queue position of current token for j-th tx
 * - tx_packet_offset[j]: packet offset within current token for j-th tx
 * - rx_bitmap_epsn: ePSN for bitmap connection
 * - rx_token_epsn: ePSN for token connection
 * - rx_token_msn: MSN for token connection
 * - bitmap_buffer[loc]: remaining tx bitmap to aggregate
 * - agg_count[loc][packet]: number of tx aggregated
 * - queue_head, queue_tail, queue_incomplete: queue pointers
 ******************************************************************************/
# 34 "./combine_control.p4"
// Index calculations






/*******************************************************************************
 * Queue Pointer Slot - manage queue pointer for each connection
 * channel_id = channel_class * EP_SIZE + _rank_id
 ******************************************************************************/

control QueuePointerSlot(
    inout bit<32> result,
    in COMBINE_QUEUE_POINTER_REG_OP operation,
    in bit<32> channel_class)
{

    Register<bit<32>, bit<32>>(8) reg_ptr;

    RegisterAction<bit<32>, bit<32>, void>(reg_ptr) ra_init = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_ptr) ra_read = {
        void apply(inout bit<32> value, out bit<32> res) {
            res = value;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_ptr) ra_inc = {
        void apply(inout bit<32> value) {
            if (value == 64 - 1) {
                value = 0;
            } else {
                value = value + 1;
            }
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_ptr) ra_read_add = {
        void apply(inout bit<32> value, out bit<32> res) {
            res = value;
            if (value >= 64 - 8) {
                value = value + 8 - 64;
            } else {
                value = value + 8;
            }
        }
    };

    // Wrapped actions - write to control's inout result directly
    action do_init(bit<32> idx) {
        ra_init.execute(idx);
    }

    action do_read(bit<32> idx) {
        result = ra_read.execute(idx);
    }

    action do_inc(bit<32> idx) {
        ra_inc.execute(idx);
    }

    action do_read_add(bit<32> idx) {
        result = ra_read_add.execute(idx);
    }

    apply {
        if (operation == COMBINE_QUEUE_POINTER_REG_OP.OP_INIT) {
            do_init(channel_class);
        } else if (operation == COMBINE_QUEUE_POINTER_REG_OP.OP_READ) {
            do_read(channel_class);
        } else if (operation == COMBINE_QUEUE_POINTER_REG_OP.OP_INC) {
            do_inc(channel_class);
        } else if (operation == COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD) {
            do_read_add(channel_class);
        }
    }
}

/*******************************************************************************
 * BitmapSlot - Bitmap buffer management for a single RX
 *
 * Each slot manages the bitmaps for all queue positions of one RX
 ******************************************************************************/
control BitmapSlot(
        out bitmap_tofino_t result,
        in bitmap_tofino_t write_val,
        in bitmap_tofino_t clear_mask,
        in COMBINE_BITMAP_REG_OP operation,
        in a2a_ingress_metadata_t ig_md)
{
    bitmap_tofino_t w_val;
    bitmap_tofino_t c_mask;

    Register<bitmap_tofino_t, bit<32>>(((8 * 8) * 64) >> 3) reg_bitmap;

    RegisterAction<bitmap_tofino_t, bit<32>, bitmap_tofino_t>(reg_bitmap) ra_read = {
        void apply(inout bitmap_tofino_t value, out bitmap_tofino_t res) {
            res = value;
        }
    };

    RegisterAction<bitmap_tofino_t, bit<32>, void>(reg_bitmap) ra_write = {
        void apply(inout bitmap_tofino_t value) {
            value = w_val;
        }
    };

    RegisterAction<bitmap_tofino_t, bit<32>, bitmap_tofino_t>(reg_bitmap) ra_clear_bit = {
        void apply(inout bitmap_tofino_t value, out bitmap_tofino_t res) {
            value = value ^ c_mask;
            res = value;
        }
    };

    RegisterAction<bitmap_tofino_t, bit<32>, void>(reg_bitmap) ra_reset = {
        void apply(inout bitmap_tofino_t value) {
            value = 0;
        }
    };

    // Wrapped actions - write to control's out result directly
    action do_read(bit<32> idx) {
        result = ra_read.execute(idx);
    }

    action do_write(bit<32> idx) {
        ra_write.execute(idx);
    }

    action do_clear_bit(bit<32> idx) {
        result = ra_clear_bit.execute(idx);
    }

    action do_reset(bit<32> idx) {
        ra_reset.execute(idx);
    }

    apply {
        if (operation == COMBINE_BITMAP_REG_OP.OP_READ) {
            do_read(ig_md.slot_index);
        } else if (operation == COMBINE_BITMAP_REG_OP.OP_WRITE) {
            w_val = write_val;
            do_write(ig_md.slot_index);
        } else if (operation == COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT) {
            c_mask = clear_mask;
            do_clear_bit(ig_md.slot_index);
        } else if (operation == COMBINE_BITMAP_REG_OP.OP_RESET) {
            do_reset(ig_md.slot_index);
        }
    }
}


/*******************************************************************************
 * AddrSlot - 1/8 of the Addr Buffer
 *
 * Adjacent tokens are distributed across 8 slots
 * ig_md.token_idx = channel_id * COMBINE_QUEUE_LENGTH + loc
 * slot_id = ig_md.token_idx % 8 = ig_md.token_idx[2:0]
 * ig_md.slot_index = ig_md.token_idx / 8 = ig_md.token_idx >> 3
 ******************************************************************************/
control AddrSlot(
    out addr_tofino_t result,
    in addr_tofino_t write_val,
    in COMBINE_ADDR_REG_OP operation,
    in a2a_ingress_metadata_t ig_md)
{

    // each slot stores COMBINE_BITMAP_ENTRIES / 8 addrs
    Register<addr_half_t, bit<32>>(((8 * 8) * 64) >> 3) reg_addr_lo;

    // read
    RegisterAction<addr_half_t, bit<32>, addr_half_t>(reg_addr_lo) ra_lo_read = {
        void apply(inout addr_half_t value, out addr_half_t res) {
            res = value;
        }
    };

    // write
    RegisterAction<addr_half_t, bit<32>, void>(reg_addr_lo) ra_lo_write = {
        void apply(inout addr_half_t value) {
            value = write_val[31:0];
        }
    };

    // each slot stores COMBINE_BITMAP_ENTRIES / 8 addrs
    Register<addr_half_t, bit<32>>(((8 * 8) * 64) >> 3) reg_addr_hi;

    // read
    RegisterAction<addr_half_t, bit<32>, addr_half_t>(reg_addr_hi) ra_hi_read = {
        void apply(inout addr_half_t value, out addr_half_t res) {
            res = value;
        }
    };

    // write
    RegisterAction<addr_half_t, bit<32>, void>(reg_addr_hi) ra_hi_write = {
        void apply(inout addr_half_t value) {
            value = write_val[63:32];
        }
    };

    // Wrapped actions - write to control's out result directly
    action do_lo_read(bit<32> idx) {
        result[31:0] = ra_lo_read.execute(idx);
    }

    action do_hi_read(bit<32> idx) {
        result[63:32] = ra_hi_read.execute(idx);
    }

    action do_lo_write(bit<32> idx) {
        ra_lo_write.execute(idx);
    }

    action do_hi_write(bit<32> idx) {
        ra_hi_write.execute(idx);
    }

    apply {
        if (operation == COMBINE_ADDR_REG_OP.OP_READ) {
            do_lo_read(ig_md.slot_index);
            do_hi_read(ig_md.slot_index);
        } else if (operation == COMBINE_ADDR_REG_OP.OP_WRITE) {
            do_lo_write(ig_md.slot_index);
            do_hi_write(ig_md.slot_index);
        }
    }
}


/*******************************************************************************
 * CombineIngress - main control logic
 ******************************************************************************/
control CombineIngress(
    inout a2a_headers_t hdr,
    inout a2a_ingress_metadata_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)
{

    /***************************************************************************
     * Variables
     ***************************************************************************/

    // Temporary variables for register action results
    bit<32> tmp_result_32;
    bit<32> tmp_result_8;

    /***************************************************************************
     * TX State Registers
     * Index: channel_id * EP_SIZE + ing_rank_id
     ***************************************************************************/
    Register<bit<32>, bit<32>>(((8 * 8) * 8), 0) reg_tx_epsn;
    Register<bit<32>, bit<32>>(((8 * 8) * 8)) reg_tx_msn;
    Register<bit<32>, bit<32>>(((8 * 8) * 8)) reg_tx_loc;
    Register<bit<32>, bit<32>>(((8 * 8) * 8)) reg_tx_packet_offset;


    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_epsn) ra_read_cond_inc_tx_epsn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            if( ig_md.psn_to_check == value) {
                value = value + 1;
            }
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_epsn) ra_init_tx_epsn = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_msn) ra_read_tx_msn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_msn) ra_read_inc_tx_msn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            value = value + 1;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_msn) ra_init_tx_msn = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_loc) ra_read_tx_loc = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_loc) ra_write_tx_loc = {
        void apply(inout bit<32> value) {
            value = ig_md.bridge.tx_loc_val;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_tx_packet_offset) ra_read_inc_tx_offset = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            value = value + 1;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_tx_packet_offset) ra_reset_tx_offset = {
            void apply(inout bit<32> value) {
            value = 1; // reset to 1 (current packet is 0, next is 1)
        }
    };

    // Wrapped actions for TX state registers - write to tmp variables
    action do_read_cond_inc_tx_epsn(bit<32> idx) {
        tmp_result_32 = ra_read_cond_inc_tx_epsn.execute(idx);
    }

    action do_init_tx_epsn(bit<32> idx) {
        ra_init_tx_epsn.execute(idx);
    }

    action do_read_tx_msn(bit<32> idx) {
        tmp_result_32 = ra_read_tx_msn.execute(idx);
    }

    action do_read_inc_tx_msn(bit<32> idx) {
        tmp_result_32 = ra_read_inc_tx_msn.execute(idx);
    }

    action do_init_tx_msn(bit<32> idx) {
        ra_init_tx_msn.execute(idx);
    }

    action do_read_tx_loc(bit<32> idx) {
        tmp_result_8 = ra_read_tx_loc.execute(idx);
    }

    action do_write_tx_loc(bit<32> idx) {
        ra_write_tx_loc.execute(idx);
    }

    action do_read_inc_tx_offset(bit<32> idx) {
        tmp_result_8 = ra_read_inc_tx_offset.execute(idx);
    }

    action do_reset_tx_offset(bit<32> idx) {
        ra_reset_tx_offset.execute(idx);
    }

    /***************************************************************************
     * RX State Registers
     * Index: channel_id
     ***************************************************************************/
    Register<bit<32>, bit<32>>((8 * 8), 0) reg_rx_bitmap_epsn;
    Register<bit<32>, bit<32>>((8 * 8), 0) reg_rx_token_epsn;
    Register<bit<32>, bit<32>>((8 * 8), 0) reg_rx_token_msn;

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_rx_bitmap_epsn) ra_read_rx_bitmap_epsn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_rx_bitmap_epsn) ra_read_cond_inc_rx_bitmap_epsn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            if (ig_md.psn_to_check == value) {
                // PSN matches: increment value
                value = value + 1;
            }
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_rx_bitmap_epsn) ra_init_rx_bitmap_epsn = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };


    // Read current epsn (do not update)
    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_rx_token_epsn) ra_read_rx_token_epsn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
        }
    };

    // Read and add TOKEN_PACKETS
    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_rx_token_epsn) ra_read_add_rx_token_epsn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            value = value + (7168 / 1024);
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_rx_token_epsn) ra_init_rx_token_epsn = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_rx_token_msn) ra_read_inc_rx_token_msn = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            value = value + 1;
        }
    };

    // Wrapped actions for RX state registers
    action do_read_rx_bitmap_epsn(bit<32> idx) {
        tmp_result_32 = ra_read_rx_bitmap_epsn.execute(idx);
    }

    action do_read_cond_inc_rx_bitmap_epsn(bit<32> idx) {
        tmp_result_32 = ra_read_cond_inc_rx_bitmap_epsn.execute(idx);
    }

    action do_init_rx_bitmap_epsn(bit<32> idx) {
        ra_init_rx_bitmap_epsn.execute(idx);
    }

    action do_read_rx_token_epsn(bit<32> idx) {
        tmp_result_32 = ra_read_rx_token_epsn.execute(idx);
    }

    action do_read_add_rx_token_epsn(bit<32> idx) {
        tmp_result_32 = ra_read_add_rx_token_epsn.execute(idx);
    }

    action do_init_rx_token_epsn(bit<32> idx) {
        ra_init_rx_token_epsn.execute(idx);
    }

    action do_read_inc_rx_token_msn(bit<32> idx) {
        tmp_result_32 = ra_read_inc_rx_token_msn.execute(idx);
    }

    /***************************************************************************
     * Queue State Registers
     * Index: rank_id choose which slot and channel_class is the index 
     * Queue Pointer Slots (EP_SIZE = 8)
    * Each RX has its own queue_head and queue_tail
     ***************************************************************************/

    // Queue Head Slots
    QueuePointerSlot() queue_head_slot_0;
    QueuePointerSlot() queue_head_slot_1;
    QueuePointerSlot() queue_head_slot_2;
    QueuePointerSlot() queue_head_slot_3;
    QueuePointerSlot() queue_head_slot_4;
    QueuePointerSlot() queue_head_slot_5;
    QueuePointerSlot() queue_head_slot_6;
    QueuePointerSlot() queue_head_slot_7;

    // Queue Tail Slots
    QueuePointerSlot() queue_tail_slot_0;
    QueuePointerSlot() queue_tail_slot_1;
    QueuePointerSlot() queue_tail_slot_2;
    QueuePointerSlot() queue_tail_slot_3;
    QueuePointerSlot() queue_tail_slot_4;
    QueuePointerSlot() queue_tail_slot_5;
    QueuePointerSlot() queue_tail_slot_6;
    QueuePointerSlot() queue_tail_slot_7;

    /***************************************************************************
     * Queue Incomplete Registers
     * Index: channel channel_id
     * Ignore the packet loss, queue queue_head and incomplete pointer are the same 
     ***************************************************************************/

    Register<bit<32>, bit<32>>((8 * 8)) reg_queue_incomplete;

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_queue_incomplete) ra_read_queue_incomplete = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_queue_incomplete) ra_read_cond_inc_queue_incomplete = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            if(value == ig_md.bridge.tx_loc_val) {
                if (value >= 64 - 1) {
                    value = 0;
                } else {
                    value = value + 1;
                }
            }
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_queue_incomplete) ra_init_queue_incomplete = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    // Wrapped actions for queue incomplete
    action do_read_queue_incomplete(bit<32> idx) {
        tmp_result_8 = ra_read_queue_incomplete.execute(idx);
    }

    action do_read_cond_inc_queue_incomplete(bit<32> idx) {
        tmp_result_8 = ra_read_cond_inc_queue_incomplete.execute(idx);
    }

    action do_init_queue_incomplete(bit<32> idx) {
        ra_init_queue_incomplete.execute(idx);
    }

    /***************************************************************************
     * Buffer Token State Registers
    * One element per token
    * Index: channel_id * COMBINE_QUEUE_LENGTH + loc  // in bitmap, loc = queue_tail (before inc)
    * Bitmap Slots - each packet corresponds to BITMAP_PER_PACKET (8) bitmap slots for distributed writes
    * Addr Slots - each packet corresponds to 8 addr slots for distributed writes
     ***************************************************************************/

    BitmapSlot() bitmap_slot_0;
    BitmapSlot() bitmap_slot_1;
    BitmapSlot() bitmap_slot_2;
    BitmapSlot() bitmap_slot_3;
    BitmapSlot() bitmap_slot_4;
    BitmapSlot() bitmap_slot_5;
    BitmapSlot() bitmap_slot_6;
    BitmapSlot() bitmap_slot_7;

    AddrSlot() addr_slot_0;
    AddrSlot() addr_slot_1;
    AddrSlot() addr_slot_2;
    AddrSlot() addr_slot_3;
    AddrSlot() addr_slot_4;
    AddrSlot() addr_slot_5;
    AddrSlot() addr_slot_6;
    AddrSlot() addr_slot_7;

    Register<bit<32>, bit<32>>(((8 * 8) * 64)) reg_clear_buffer;


    // Before calling, set ig_md.bridge.tx_offset_val; a Register can only be read once, so write it this way
    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_clear_buffer) ra_read_set_clear = {
        void apply(inout bit<32> value, out bit<32> result) {
            result = value;
            if(value <= ig_md.bridge.tx_offset_val){ // ideally should be ==
                value = value + 1;
            }
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_clear_buffer) ra_reset_clear = {
        void apply(inout bit<32> value) {
            value = 0;
        }
    };

    // Wrapped actions for clear buffer
    action do_read_set_clear(bit<32> idx) {
        tmp_result_8 = ra_read_set_clear.execute(idx);
    }

    action do_reset_clear(bit<32> idx) {
        ra_reset_clear.execute(idx);
    }

    /***************************************************************************
     * Variables
     ***************************************************************************/
    bit<32> channel_id;
    bit<32> channel_class;
    bit<32> queue_head;
    bit<32> queue_tail;
    bit<32> queue_incomplete;
    bit<32> tx_reg_idx;
    bit<32> buffer_idx;

    bit<32> slot_id;

    //bit<32> token_idx;

    /***************************************************************************
     * Utility Actions
     ***************************************************************************/
    bit<32> tmp_mul_256;

    action mul_256(){
        tmp_mul_256 = tmp_mul_256 * 256;
    }

    action set_aeth_msn() {
        ig_md.bridge.has_aeth = true;
        hdr.aeth.setValid();
        hdr.aeth.msn = tmp_mul_256 * 256;
    }

    action set_aeth_syndrome(bit<32> syndrome) {
        hdr.aeth.msn = hdr.aeth.msn + syndrome;
    }

    action set_aeth_psn(bit<32> psn) {
        hdr.bth.psn = psn; // If there's an ack header (e.g., RDMA_OP_ACK or Read response), PSN is determined by the ack, set here

    }

    action swap_l2_l3_l4() {
        bit<48> tmp_mac = hdr.eth.src_addr;
        hdr.eth.src_addr = hdr.eth.dst_addr;
        hdr.eth.dst_addr = tmp_mac;

        bit<32> tmp_ip = hdr.ipv4.src_addr;
        hdr.ipv4.src_addr = hdr.ipv4.dst_addr;
        hdr.ipv4.dst_addr = tmp_ip;

        bit<16> tmp_port = hdr.udp.src_port;
        hdr.udp.src_port = hdr.udp.dst_port;
        hdr.udp.dst_port = tmp_port;
    }

    action set_ack_len() {
        // ACK packet: UDP(8) + BTH(12) + AETH(4) + ICRC(4) = 28
        hdr.udp.length = 28;
        hdr.ipv4.total_len = 48;
        hdr.udp.checksum = 0;
    }

    /*
     * ig_md.bitmap_clear_mask
     */

    action set_bitmap_clear_mask(bitmap_tofino_t m) {
        ig_md.bitmap_clear_mask = m;
    }

    table tbl_rank_to_clear_mask {
        key = {
            ig_md.bridge.ing_rank_id : exact;
        }
        actions = {
            set_bitmap_clear_mask;
        }
        size = 8;
        default_action = set_bitmap_clear_mask((bitmap_tofino_t)0);

        const entries = {
            0 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x01);
            1 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x02);
            2 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x04);
            3 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x08);
            4 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x10);
            5 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x20);
            6 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x40);
            7 : set_bitmap_clear_mask((bitmap_tofino_t)8w0x80);
        }
    }

    /***************************************************************************
    * Index Calculation Actions - 拆分复杂计算
    ***************************************************************************/

    /**
     * 0. devide the calculations into multiple steps    
     */
    action step1_cal_tx_reg_idx() {
        tx_reg_idx =(bit<32>)ig_md.bridge.ing_rank_id; // no use for loop port
    }

    bit<32> channel_mul_8;

    action step2_cal_tx_reg_idx() {
        channel_mul_8 = channel_id << 3; // channel_id * 8
    }

    action step3_cal_tx_reg_idx() {
        tx_reg_idx = tx_reg_idx + channel_mul_8;
    }

    // ============================================================
    // 1. ig_md.token_idx = channel_id * COMBINE_QUEUE_LENGTH + (bit<32>)queue_tail
    //    COMBINE_QUEUE_LENGTH = 64 = << 6
    // ============================================================
    bit<32> channel_mul_64;

    action step1_calc_token_idx_from_tail() {
        channel_mul_64 = channel_id << 6; // channel_id * 64
    }

    action step2_calc_token_idx_from_tail() {
        ig_md.token_idx = (bit<32>)queue_tail;
    }

    action step3_calc_token_idx_from_tail() {
        ig_md.token_idx = ig_md.token_idx + channel_mul_64;
    }

    // 使用方式:
    // step1_calc_token_idx_from_tail();
    // step2_calc_token_idx_from_tail();
    // step3_calc_token_idx_from_tail();


    // ============================================================
    // 2. ig_md.slot_index = ig_md.token_idx >> 3
    //    这个比较简单，可能单独一个action就行
    // ============================================================
    action calc_slot_index_from_token_idx() {
        ig_md.slot_index = ig_md.token_idx >> 3;
    }


    // ============================================================
    // 3. ig_md.slot_index = next_token_idx >> 3
    //    注意：这里是 slot_index 不是 token_idx
    // ============================================================
    bit<32> next_token_idx; // 需要在外部声明

    action calc_slot_index_from_next_token() {
        ig_md.slot_index = next_token_idx >> 3;
    }


    // ============================================================
    // 4. ig_md.token_idx = channel_id * 64 + (bit<32>)ig_md.bridge.tx_loc_val
    // ============================================================
    action step1_calc_token_idx_from_tx_loc() {
        channel_mul_64 = channel_id << 6; // channel_id * 64
    }

    action step2_calc_token_idx_from_tx_loc() {
        ig_md.token_idx = (bit<32>)ig_md.bridge.tx_loc_val;
    }

    action step3_calc_token_idx_from_tx_loc() {
        ig_md.token_idx = ig_md.token_idx + channel_mul_64;
    }


    bit<32> temp_head_shifted;


    action step1_calc_shift_head() {
        temp_head_shifted = queue_head << 16;
    }

    action step2_calc_combine_tail() {
        ig_md.temp_queue_data = temp_head_shifted | queue_tail;
    }

    action step3_write_payload_data_0() {
        hdr.payload.data00 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_1() {
        hdr.payload.data01 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_2() {
        hdr.payload.data02 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_3() {
        hdr.payload.data03 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_4() {
        hdr.payload.data04 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_5() {
        hdr.payload.data05 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_6() {
        hdr.payload.data06 = ig_md.temp_queue_data;
    }

    action step3_write_payload_data_7() {
        hdr.payload.data07 = ig_md.temp_queue_data;
    }


    action step1_calc_next_token_idx_from_next_loc() {
        channel_mul_64 = channel_id << 6; // channel_id * 64
    }

    action step2_calc_next_token_idx_from_next_loc() {
        next_token_idx = ig_md.next_loc;
    }

    action step3_calc_next_token_idx_from_next_loc() {
        next_token_idx = next_token_idx + channel_mul_64;
    }


    bitmap_tofino_t bitmap_result;
    bitmap_tofino_t bitmap_write_val;
    addr_tofino_t addr_result;
    addr_tofino_t addr_write_val;

    action step_write_addr_lo() {
        ig_md.bridge.next_token_addr[31:0] = addr_result[31:0];
    }

    action step_write_addr_hi() {
        ig_md.bridge.next_token_addr[63:32] = addr_result[63:32];
    }
    /***************************************************************************
     * Apply
     ***************************************************************************/
    apply {
        channel_id = ig_md.bridge.channel_id;
        channel_class = ig_md.channel_class;
        //tx_reg_idx =(bit<32>)ig_md.bridge.ing_rank_id; // no use for loop port
        step1_cal_tx_reg_idx();
        step2_cal_tx_reg_idx();
        step3_cal_tx_reg_idx();
        //bit<32> channel_multiply_8 = channel_id << 3 ;
        //bit<32> tx_reg_idx_tmp = tx_reg_idx + channel_multiply_8;
        //tx_reg_idx = tx_reg_idx_tmp;



        // ================================================================
        // CONN_CONTROL: query queue pointer (READ)
        // ================================================================
        if (ig_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_CONTROL) {
            if (hdr.bth.opcode == RDMA_OP_READ_REQ) {
                // Construct READ_RESPONSE_ONLY
                queue_head_slot_0.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_0.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_0();
                //hdr.payload.data00 = (queue_head << 16) | queue_tail;

                queue_head_slot_1.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_1.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data01 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_1();

                queue_head_slot_2.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_2.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data02 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_2();

                queue_head_slot_3.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_3.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data03 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_3();

                queue_head_slot_4.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_4.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data04 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_4();

                queue_head_slot_5.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_5.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data05 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_5();

                queue_head_slot_6.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_6.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data06 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_6();

                queue_head_slot_7.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                queue_tail_slot_7.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
                //hdr.payload.data07 = (queue_head << 16) | queue_tail;
                step1_calc_shift_head();
                step2_calc_combine_tail();
                step3_write_payload_data_0();

                tmp_mul_256 = ig_md.psn + 32w1;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
                set_aeth_psn(ig_md.psn);

                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
            }
            return;
        }

        // ================================================================
        // CONN_BITMAP: rx writes bitmap (WRITE_ONLY)
        // ================================================================
        if (ig_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_BITMAP) {
            if (hdr.bth.opcode != RDMA_OP_WRITE_ONLY) {
                ig_dprsr_md.drop_ctl = 1;
                return;
            }
            ig_md.psn_to_check = ig_md.psn;
            do_read_cond_inc_rx_bitmap_epsn(channel_id);
            bit<32> expected_psn = tmp_result_32;

            if (ig_md.psn == expected_psn) {
                // PSN matches, write bitmap
                // Select corresponding slot by rx_id to read and update queue_tail
                if (ig_md.bridge.ing_rank_id == 0) {
                    queue_tail_slot_0.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 1) {
                    queue_tail_slot_1.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 2) {
                    queue_tail_slot_2.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 3) {
                    queue_tail_slot_3.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 4) {
                    queue_tail_slot_4.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 5) {
                    queue_tail_slot_5.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 6) {
                    queue_tail_slot_6.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                } else if (ig_md.bridge.ing_rank_id == 7) {
                    queue_tail_slot_7.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ_ADD, channel_class);
                }

                // Write bitmap and addr

                step1_calc_token_idx_from_tail();
                step2_calc_token_idx_from_tail();
                step3_calc_token_idx_from_tail();
                calc_slot_index_from_token_idx(); // ig_md.token_idx / 8

                bitmap_write_val = hdr.payload.data00;
                bitmap_slot_0.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data01;
                bitmap_slot_1.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data02;
                bitmap_slot_2.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data03;
                bitmap_slot_3.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data04;
                bitmap_slot_4.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data05;
                bitmap_slot_5.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data06;
                bitmap_slot_6.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);
                bitmap_write_val = hdr.payload.data07;
                bitmap_slot_7.apply(bitmap_result, bitmap_write_val, 0, COMBINE_BITMAP_REG_OP.OP_WRITE, ig_md);

                addr_write_val[31:0] = hdr.payload.data08;
                addr_write_val[63:32] = hdr.payload.data09;
                addr_slot_0.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data0a;
                addr_write_val[63:32] = hdr.payload.data0b;
                addr_slot_1.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data0c;
                addr_write_val[63:32] = hdr.payload.data0d;
                addr_slot_2.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data0e;
                addr_write_val[63:32] = hdr.payload.data0f;
                addr_slot_3.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data10;
                addr_write_val[63:32] = hdr.payload.data11;
                addr_slot_4.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data12;
                addr_write_val[63:32] = hdr.payload.data13;
                addr_slot_5.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data14;
                addr_write_val[63:32] = hdr.payload.data15;
                addr_slot_6.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);
                addr_write_val[31:0] = hdr.payload.data16;
                addr_write_val[63:32] = hdr.payload.data17;
                addr_slot_7.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_WRITE, ig_md);

                // return ACK
                tmp_mul_256 = ig_md.psn + 32w1;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
                set_aeth_psn(ig_md.psn);
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;

            } else if (ig_md.psn < expected_psn) {
                // duplicate packet
                //set_aeth_ingress(AETH_ACK_CREDIT_INVALID, expected_psn - 1, expected_psn);
                tmp_mul_256 = expected_psn;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
                set_aeth_psn(expected_psn - 1);
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;

            } else {
                // packet loss, return NAK
                //set_aeth_ingress(AETH_NAK_SEQ_ERR, (expected_psn - 1), expected_psn);
                tmp_mul_256 = expected_psn;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_NAK_SEQ_ERR);
                set_aeth_psn(expected_psn - 1);
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
            }
            return;
        }

        // ================================================================
        // CONN_TX: tx writes token (WRITE) - aggregation
        // Bitmap storage must be in ingress to determine if token aggregation is complete and then broadcast
        // Token buffer must be in egress because broadcast needs to read packets at different offsets
        // ================================================================
        if (ig_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_TX && ig_intr_md.ingress_port != 192) {
            if (hdr.bth.opcode != RDMA_OP_WRITE_FIRST &&
                hdr.bth.opcode != RDMA_OP_WRITE_MIDDLE &&
                hdr.bth.opcode != RDMA_OP_WRITE_LAST &&
                hdr.bth.opcode != RDMA_OP_WRITE_ONLY) {
                ig_dprsr_md.drop_ctl = 1;
                return;
            }

            ig_md.psn_to_check = ig_md.psn;
            do_read_cond_inc_tx_epsn(tx_reg_idx);
            bit<32> expected_psn = tmp_result_32;
            do_read_tx_msn(tx_reg_idx);
            bit<32> current_msn = tmp_result_32;

            if (ig_md.psn == expected_psn) {
                // PSN matches
                // Get loc and packet_offset
                if (hdr.bth.opcode == RDMA_OP_WRITE_FIRST ||
                    hdr.bth.opcode == RDMA_OP_WRITE_ONLY) {
                    // Get loc from reth.addr
                    ig_md.bridge.tx_loc_val = hdr.reth.addr[63:32];
                    ig_md.bridge.tx_offset_val = 0;
                    do_write_tx_loc(tx_reg_idx);
                    do_reset_tx_offset(tx_reg_idx);
                } else {
                    // Get from registers
                    do_read_tx_loc(tx_reg_idx);
                    ig_md.bridge.tx_loc_val = tmp_result_8;
                    do_read_inc_tx_offset(tx_reg_idx);
                    ig_md.bridge.tx_offset_val = tmp_result_8;
                }

                //ig_md.token_idx = channel_id * COMBINE_QUEUE_LENGTH + (bit<32>)ig_md.bridge.tx_loc_val;
                step1_calc_token_idx_from_tx_loc();
                step2_calc_token_idx_from_tx_loc();
                step3_calc_token_idx_from_tx_loc();
                slot_id = ig_md.token_idx;
                // Check whether this is the first tx to arrive
                do_read_set_clear(ig_md.token_idx);
                ig_md.bridge.clear_offset = tmp_result_8;

                // If WRITE_LAST/ONLY: clear tx bit in bitmap and update MSN
                if (hdr.bth.opcode == RDMA_OP_WRITE_ONLY ||
                    hdr.bth.opcode == RDMA_OP_WRITE_LAST) {

                    calc_slot_index_from_token_idx(); // ig_md.token_idx / 8
                    //ig_md.slot_index = (bit<32>)ig_md.bridge.channel_id + 1;      // ig_md.token_idx / 8
                    //ig_md.bitmap_clear_mask = (bitmap_tofino_t)1 << ig_md.bridge.ing_rank_id;
                    tbl_rank_to_clear_mask.apply();
                    //bitmap_tofino_t bitmap_after_clear = ra_clear_bit_bitmap.execute(ig_md.token_idx);
                    if (slot_id == 0) {
                        bitmap_slot_0.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_0.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else if (slot_id == 1) {
                        bitmap_slot_1.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_1.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else if (slot_id == 2) {
                        bitmap_slot_2.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_2.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else if (slot_id == 3) {
                        bitmap_slot_3.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_3.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else if (slot_id == 4) {
                        bitmap_slot_4.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_4.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else if (slot_id == 5) {
                        bitmap_slot_5.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_5.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else if (slot_id == 6) {
                        bitmap_slot_6.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_6.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    } else { // slot_id == 7
                        bitmap_slot_7.apply(bitmap_result, bitmap_write_val, ig_md.bitmap_clear_mask, COMBINE_BITMAP_REG_OP.OP_CLEAR_BIT, ig_md);
                        addr_slot_7.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                    }

                    do_read_inc_tx_msn(tx_reg_idx);
                    current_msn = tmp_result_32;
                    if (bitmap_result == 0) {
                        do_read_cond_inc_queue_incomplete(channel_id);
                        queue_incomplete = tmp_result_8;
                        if( queue_incomplete == ig_md.bridge.tx_loc_val) {
                            // Update queue_head to match queue_incomplete
                            if (ig_md.bridge.ing_rank_id == 0) {
                                queue_head_slot_0.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 1) {
                                queue_head_slot_1.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 2) {
                                queue_head_slot_2.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 3) {
                                queue_head_slot_3.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 4) {
                                queue_head_slot_4.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 5) {
                                queue_head_slot_5.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 6) {
                                queue_head_slot_6.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            } else if (ig_md.bridge.ing_rank_id == 7) {
                                queue_head_slot_7.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                            }

                            ig_tm_md.mcast_grp_b = 200; // loopback group

                            // Convert packet to WRITE_FIRST; length and other fields are not set.
                            // On the first loop startup the incoming packet may have no RETH and may not fit.
                            //ig_md.bridge.next_token_addr = addr_result;
                            //ig_md.bridge.next_token_addr[31:0] = addr_result[31:0];
                            //ig_md.bridge.next_token_addr[63:32] = addr_result[63:32];
                            step_write_addr_lo();
                            step_write_addr_hi();

                        }
                    }
                }

                // return ACK
                //set_aeth_ingress(AETH_ACK_CREDIT_INVALID, expected_psn, current_msn);
                tmp_mul_256 = current_msn;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
                set_aeth_psn(expected_psn);
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;

            } else if (ig_md.psn < expected_psn) {
                // duplicate packet
                //set_aeth_ingress(AETH_ACK_CREDIT_INVALID, (expected_psn - 1), current_msn);
                tmp_mul_256 = current_msn;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_ACK_CREDIT_INVALID);
                set_aeth_psn(expected_psn - 1);
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;

            } else {
                // packet loss
                //set_aeth_ingress(AETH_NAK_SEQ_ERR, (expected_psn - 1), current_msn);
                tmp_mul_256 = current_msn;
                mul_256();
                set_aeth_msn();
                set_aeth_syndrome(AETH_NAK_SEQ_ERR);
                set_aeth_psn(expected_psn - 1);
                ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;
            }
            return;
        }

        // ================================================================
        // loopback port; LOOPBACK_PORT not defined yet
        // This packet is guaranteed to be a WRITE_FIRST
        // reth
        //  data00: during ingress it's the token's bcast loc; during egress it's the next token's bcast loc
        // addr for this token remains unchanged during reception; during egress the loopback port will be set to the next token address stored in bridge during ingress
        // Fields of this packet are mostly set by the previous egress, except PSN, opcode, and payload which vary per packet.
        // ================================================================
        if (ig_intr_md.ingress_port == 192 &&
            hdr.bth.opcode == RDMA_OP_WRITE_FIRST) {

            // Get current loc from payload
            //bit<32> current_loc = hdr.payload.data00;
            ig_md.bridge.tx_loc_val = hdr.payload.data00;
            ig_md.bridge.is_loopback = true;

            // Set multicast to rx (TOKEN_PACKETS packets)
            bit<32> group = 100 + ig_md.bridge.root_rank_id;
            ig_tm_md.mcast_grp_a = (bit<16>)group;

            do_read_add_rx_token_epsn(channel_id);
            hdr.bth.psn = tmp_result_32;

            // Compute next loc (circular queue)
            if (hdr.payload.data00 >= 64 - 1) {
                ig_md.next_loc = 0;
            } else {
                ig_md.next_loc = hdr.payload.data00 + 1;
            }

            // Read queue_tail to check if tail is reached
            if (ig_md.bridge.root_rank_id == 0) {
                queue_tail_slot_0.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 1) {
                queue_tail_slot_1.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 2) {
                queue_tail_slot_2.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 3) {
                queue_tail_slot_3.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 4) {
                queue_tail_slot_4.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 5) {
                queue_tail_slot_5.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 6) {
                queue_tail_slot_6.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            } else if (ig_md.bridge.root_rank_id == 7) {
                queue_tail_slot_7.apply(queue_tail, COMBINE_QUEUE_POINTER_REG_OP.OP_READ, channel_class);
            }

            // If ig_md.next_loc == queue_tail, all tokens are processed; stop loopback
            if (ig_md.next_loc != queue_tail) {
                // Check if bitmap of next loc is zero
                //next_token_idx = channel_id * COMBINE_QUEUE_LENGTH + ig_md.next_loc;
                step1_calc_next_token_idx_from_next_loc();
                step2_calc_next_token_idx_from_next_loc();
                step3_calc_next_token_idx_from_next_loc();

                bit<32> next_slot_id = next_token_idx;
                calc_slot_index_from_next_token();

                bitmap_tofino_t next_bitmap_result;

                if (next_slot_id == 0) {
                    bitmap_slot_0.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_0.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else if (next_slot_id == 1) {
                    bitmap_slot_1.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_1.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else if (next_slot_id == 2) {
                    bitmap_slot_2.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_2.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else if (next_slot_id == 3) {
                    bitmap_slot_3.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_3.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else if (next_slot_id == 4) {
                    bitmap_slot_4.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_4.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else if (next_slot_id == 5) {
                    bitmap_slot_5.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_5.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else if (next_slot_id == 6) {
                    bitmap_slot_6.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_6.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                } else {
                    bitmap_slot_7.apply(next_bitmap_result, 0, 0, COMBINE_BITMAP_REG_OP.OP_READ, ig_md);
                    addr_slot_7.apply(addr_result, addr_write_val, COMBINE_ADDR_REG_OP.OP_READ, ig_md);
                }

                // Check queue_incomplete
                //bit<32> queue_incomplete_val = ra_read_queue_incomplete.execute(channel_id);

                // If next token is ready, continue loopback
                if (next_bitmap_result == 0 ) { //&& ig_md.next_loc == queue_incomplete_val
                    // Update queue_incomplete and queue_head
                    ig_md.bridge.tx_loc_val = ig_md.next_loc;
                    do_read_cond_inc_queue_incomplete(channel_id);
                    queue_incomplete = tmp_result_8;
                    // Restore current loc for egress
                    ig_md.bridge.tx_loc_val = hdr.payload.data00;

                    if (ig_md.bridge.root_rank_id == 0) {
                        queue_head_slot_0.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 1) {
                        queue_head_slot_1.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 2) {
                        queue_head_slot_2.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 3) {
                        queue_head_slot_3.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 4) {
                        queue_head_slot_4.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 5) {
                        queue_head_slot_5.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 6) {
                        queue_head_slot_6.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    } else if (ig_md.bridge.root_rank_id == 7) {
                        queue_head_slot_7.apply(queue_head, COMBINE_QUEUE_POINTER_REG_OP.OP_INC, channel_class);
                    }

                    // Set loopback to continue and update payload.data00 to ig_md.next_loc
                    ig_tm_md.mcast_grp_b = 200;
                    hdr.payload.data00 = ig_md.next_loc;
                    //ig_md.bridge.next_token_addr[31:0] = addr_result[31:0];
                    //ig_md.bridge.next_token_addr[63:32] = addr_result[63:32];
                    step_write_addr_lo();
                    step_write_addr_hi();
                }
            }



            return;
        }

    }
}


/*******************************************************************************
 * CombineEgress
 * Processing:
 * 1. Loopback port output - construct WRITE_FIRST to continue loop
 * 2. Broadcast to rx - set opcode by rid, read aggregation result
 * 3. CONN_TX - aggregate and return ACK
 * 4. Other ACK packets
 ******************************************************************************/
control CombineEgress(
    inout a2a_headers_t hdr,
    inout a2a_egress_metadata_t eg_md,
    in egress_intrinsic_metadata_t eg_intr_md,
    inout egress_intrinsic_metadata_for_deparser_t eg_dprsr_md)
{
    /***************************************************************************
     * Aggregator
     * Index: channel_id * PACKET_NUM_PER_CHANNEL_BUFFER + loc * TOKEN_PACKETS + packet_offset 
     ***************************************************************************/
    bit<32> agg_val;
    bit<32> buffer_idx;
    bit<32> channel_id;

    // Temporary variable for register action results
    bit<32> tmp_agg_result;

    Register<bit<32>, bit<32>>(((8 * 8) * (64 * (7168 / 1024)))) reg_agg;

    RegisterAction<bit<32>, bit<32>, void>(reg_agg) ra_store = {
        void apply(inout bit<32> value) {
            value = agg_val;
        }
    };

    RegisterAction<bit<32>, bit<32>, void>(reg_agg) ra_aggregate = {
        void apply(inout bit<32> value) {
            value = value + agg_val;
        }
    };

    RegisterAction<bit<32>, bit<32>, bit<32>>(reg_agg) ra_read_agg = {
        void apply(inout bit<32> value, out bit<32> res) {
            res = value;
        }
    };

    // Wrapped actions for aggregator - write to tmp variable
    action do_store(bit<32> idx) {
        ra_store.execute(idx);
    }

    action do_aggregate(bit<32> idx) {
        ra_aggregate.execute(idx);
    }

    action do_read_agg(bit<32> idx) {
        tmp_agg_result = ra_read_agg.execute(idx);
    }

    /***************************************************************************
     * Utility Actions
     ***************************************************************************/
    action swap_l2_l3_l4() {
        bit<48> tmp_mac = hdr.eth.src_addr;
        hdr.eth.src_addr = hdr.eth.dst_addr;
        hdr.eth.dst_addr = tmp_mac;

        bit<32> tmp_ip = hdr.ipv4.src_addr;
        hdr.ipv4.src_addr = hdr.ipv4.dst_addr;
        hdr.ipv4.dst_addr = tmp_ip;

        bit<16> tmp_port = hdr.udp.src_port;
        hdr.udp.src_port = hdr.udp.dst_port;
        hdr.udp.dst_port = tmp_port;
    }

    action set_ack_len() {
        // ACK: UDP(8) + BTH(12) + AETH(4) + ICRC(4) = 28
        hdr.udp.length = 28;
        hdr.ipv4.total_len = 48;
        hdr.udp.checksum = 0;
        //hdr.bth.opcode = RDMA_OP_ACK;
    }

    action set_write_first_len() {
        // WRITE_FIRST: UDP(8) + BTH(12) + RETH(16) + Payload(PAYLOAD_LEN) + ICRC(4)
        hdr.udp.length = 8 + 12 + 16 + 1024 + 4;
        hdr.ipv4.total_len = 20 + 8 + 12 + 16 + 1024 + 4;
        hdr.udp.checksum = 0;
    }

    action set_write_middle_len() {
        // WRITE_MIDDLE/LAST: UDP(8) + BTH(12) + Payload(PAYLOAD_LEN) + ICRC(4)
        hdr.udp.length = 8 + 12 + 1024 + 4;
        hdr.ipv4.total_len = 20 + 8 + 12 + 1024 + 4;
        hdr.udp.checksum = 0;
    }

    /***************************************************************************
     * RX info table - used to construct WRITE_FIRST for loopback
     ***************************************************************************/
    action set_rx_info(bit<48> dst_mac, bit<32> dst_ip, bit<32> dst_qp, bit<32> rkey) {
        hdr.eth.dst_addr = dst_mac;
        hdr.ipv4.dst_addr = dst_ip;
        hdr.bth.dst_qp = dst_qp;
        hdr.reth.rkey = rkey;
    }

    table tbl_rx_info {
        key = {
            eg_md.bridge.channel_id : exact;
            eg_md.bridge.root_rank_id : exact;
        }
        actions = {
            set_rx_info;
            NoAction;
        }
        size = 1024;
        default_action = NoAction;
    }

        // ============================================================
    // 5. buffer_idx = channel_id * (64 * (7168 / 1024)) = channel_id * 448
    //    448 = 512 - 64 = (1 << 9) - (1 << 6)
    //    
    //    完整公式: buffer_idx = channel_id * 448 + loc * 7 + offset
    //    7 = 8 - 1 = (1 << 3) - 1
    // ============================================================

    // 中间变量声明
    bit<32> channel_mul_512;
    bit<32> channel_mul_64;
    bit<32> channel_mul_448;
    bit<32> tmp_loc; // 存储 loc 值
    bit<32> loc_mul_8;
    bit<32> loc_mul_7;
    bit<32> tmp_offset; // 存储 offset 值

    // ============================================================
    // buffer_idx = channel_id * 448 + loc * 7 + offset
    // 448 = 512 - 64
    // 7 = 8 - 1
    // ============================================================

    // Step 1: channel_id * 512
    action step1_calc_buffer_idx() {
        channel_mul_512 = channel_id << 9;
    }

    // Step 2: channel_id * 64
    action step2_calc_buffer_idx() {
        channel_mul_64 = channel_id << 6;
    }

    // Step 3: channel_id * 448 = 512 - 64
    action step3_calc_buffer_idx() {
        channel_mul_448 = channel_mul_512 - channel_mul_64;
    }

    // Step 4a: 设置 tmp_loc (用于存储 loc 的值)
    action step4a_set_loc_from_tx_loc() {
        tmp_loc = (bit<32>)eg_md.bridge.tx_loc_val;
    }

    // Step 4b: loc * 8
    action step4b_calc_loc_mul_8() {
        loc_mul_8 = tmp_loc << 3;
    }

    // Step 5: loc * 7 = loc * 8 - loc
    action step5_calc_loc_mul_7() {
        loc_mul_7 = loc_mul_8 - tmp_loc;
    }

    // Step 6: buffer_idx = channel_mul_448 + loc_mul_7
    action step6_calc_buffer_idx() {
        buffer_idx = channel_mul_448 + loc_mul_7;
    }

    // Step 7a: 设置 tmp_offset
    action step7a_set_offset_from_tx_offset() {
        tmp_offset = (bit<32>)eg_md.bridge.tx_offset_val;
    }

    action step7a_set_offset_from_rid() {
        tmp_offset = (bit<32>)eg_intr_md.egress_rid;
    }

    action step7a_set_offset_from_eg() {
        tmp_offset = (bit<32>)eg_md.bridge.tx_offset_val;
    }
    // Step 7b: buffer_idx = buffer_idx + offset
    action step7b_add_offset() {
        buffer_idx = buffer_idx + tmp_offset;
    }

    // 使用方式 (在 egress):
    // step1_calc_buffer_idx();
    // step2_calc_buffer_idx();
    // step3_calc_buffer_idx();
    // step4_calc_buffer_idx((bit<32>)eg_md.bridge.tx_loc_val);
    // step5_calc_buffer_idx((bit<32>)eg_md.bridge.tx_loc_val);
    // step6_calc_buffer_idx();
    // step7_calc_buffer_idx((bit<32>)pkt_offset);

    bit<32> pkt_offset;

    action step1_prep_offset() {
        pkt_offset = (bit<32>)eg_intr_md.egress_rid;
    }


    action step2_calc_psn_add() {
        eg_md.psn = eg_md.psn + pkt_offset;
    }

    action step3_write_bth_psn() {
        hdr.bth.psn = eg_md.psn;
    }
    /***************************************************************************
     * Apply
     ***************************************************************************/
    apply {

        channel_id = (bit<32>)eg_md.bridge.channel_id;

        // ================================================================
        // 1. Loopback port output - construct WRITE_FIRST to send to loopback for continued processing
        // ================================================================
        if (eg_intr_md.egress_port == 192) {
            // Construct full WRITE_FIRST
            hdr.bth.opcode = RDMA_OP_WRITE_FIRST;

            // Set RETH
            hdr.reth.setValid();
            hdr.reth.addr = eg_md.bridge.next_token_addr;

            hdr.reth.len = 7168;

            // Set payload.data00 to store loc
            hdr.payload.setValid();
            if (!eg_md.bridge.is_loopback) {
                // From CONN_TX: first time starting loop, set current loc
                hdr.payload.data00 = eg_md.bridge.tx_loc_val;
            }
            // If is_loopback, payload.data00 was already set to ig_md.next_loc in ingress

            // Lookup table to set rx info (dst_mac, dst_ip, dst_qp, rkey)
            tbl_rx_info.apply();

            // Set packet length
            set_write_first_len();

            // AETH invalid
            hdr.aeth.setInvalid();

            return;
        }

        // ================================================================
        // 2. is_loopback broadcast packets - send TOKEN_PACKETS packets to rx
        // ================================================================
        if (eg_intr_md.egress_port != 192 && eg_md.bridge.is_loopback) {
            // Determine which packet based on egress_rid (0 to TOKEN_PACKETS-1)
            step1_prep_offset();
            step2_calc_psn_add();
            step3_write_bth_psn();

            // Compute buffer index and read aggregation result
            step1_calc_buffer_idx(); // channel * 512
            step2_calc_buffer_idx(); // channel * 64
            step3_calc_buffer_idx(); // channel * 448
            step4a_set_loc_from_tx_loc(); // tmp_loc = tx_loc_val
            step4b_calc_loc_mul_8(); // loc * 8
            step5_calc_loc_mul_7(); // loc * 7
            step6_calc_buffer_idx(); // channel*448 + loc*7
            step7a_set_offset_from_rid(); // tmp_offset = egress_rid
            step7b_add_offset(); // + offset

            do_read_agg(buffer_idx);
            bit<32> agg_result = tmp_agg_result;

            // Set payload
            hdr.payload.setValid();
            hdr.payload.data00 = agg_result;

            // Set opcode and header based on pkt_offset
            if (pkt_offset == 0) {
                // First packet: WRITE_FIRST
                hdr.bth.opcode = RDMA_OP_WRITE_FIRST;
                // RETH address preserved from original packet during ingress
                hdr.reth.setValid();
                hdr.reth.len = 7168;
                set_write_first_len();
            } else if (pkt_offset == (7168 / 1024) - 1) {
                // Last packet: WRITE_LAST
                hdr.bth.opcode = RDMA_OP_WRITE_LAST;
                hdr.reth.setInvalid();
                set_write_middle_len();
            } else {
                // Middle packet: WRITE_MIDDLE
                hdr.bth.opcode = RDMA_OP_WRITE_MIDDLE;
                hdr.reth.setInvalid();
                set_write_middle_len();
            }

            // AETH invalid (WRITE packets do not have AETH)
            hdr.aeth.setInvalid();

            return;
        }

        // ================================================================
        // 3. CONN_TX - aggregate data and return ACK
        // ================================================================
        if (eg_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_TX &&
            eg_intr_md.egress_port != 192) {
            // Compute buffer index
            // buffer_idx = channel_id * PACKET_NUM_PER_CHANNEL_BUFFER 
            //            + (bit<32>)eg_md.bridge.tx_loc_val * TOKEN_PACKETS 
            //            + (bit<32>)eg_md.bridge.tx_offset_val;
            step1_calc_buffer_idx(); // channel * 512
            step2_calc_buffer_idx(); // channel * 64
            step3_calc_buffer_idx(); // channel * 448
            step4a_set_loc_from_tx_loc(); // tmp_loc = tx_loc_val
            step4b_calc_loc_mul_8(); // loc * 8
            step5_calc_loc_mul_7(); // loc * 7
            step6_calc_buffer_idx(); // channel*448 + loc*7
            step7a_set_offset_from_eg(); // tmp_offset = tx_offset_val
            step7b_add_offset(); // + offset

            agg_val = hdr.payload.data00; // only data00 is used for aggregation

            // Aggregate or store
            if (eg_md.bridge.clear_offset <= eg_md.bridge.tx_offset_val) {
                do_store(buffer_idx);
            } else {
                do_aggregate(buffer_idx);
            }

            // Set ACK packet
            swap_l2_l3_l4();
            set_ack_len();

            // Set header valid/invalid
            // AETH syndrome/psn/msn already set in ingress
            hdr.aeth.setValid();
            hdr.bth.opcode = RDMA_OP_ACK;
            hdr.reth.setInvalid();
            hdr.payload.setInvalid();

            return;
        }

        // ================================================================
        // 4. CONN_CONTROL READ_RESPONSE (completed in ingress, only need to set)
        // ================================================================
        if (eg_md.bridge.conn_semantics == CONN_SEMANTICS.CONN_CONTROL) {
            // Set packet length: UDP: BTH(12) + AETH(4) + Payload(128) + ICRC(4) = 148, + UDP header(8) = 156; IP: UDP(156) + IP header(20) = 176
            hdr.udp.length = 156;
            hdr.ipv4.total_len = 176;
            hdr.udp.checksum = 0;
            swap_l2_l3_l4();
            hdr.reth.setInvalid();
            hdr.payload.setValid();
            hdr.bth.opcode = RDMA_OP_READ_RES_ONLY;
            return;
        }

        // ================================================================
        // 5. Other ACK packets (CONN_BITMAP)
        // ================================================================
        if (eg_md.bridge.has_aeth) {
            swap_l2_l3_l4();
            set_ack_len();
            hdr.reth.setInvalid();
            hdr.payload.setInvalid();
            hdr.bth.opcode = RDMA_OP_ACK;
            return;
        }


    }
}
# 8 "a2a.p4" 2
# 1 "./a2a_ingress_parser.p4" 1
parser A2AIngressParser(
    packet_in pkt,
    out a2a_headers_t hdr,
    out a2a_ingress_metadata_t ig_md,
    out ingress_intrinsic_metadata_t ig_intr_md)
{
    state start {
        pkt.extract(ig_intr_md);
        pkt.advance(PORT_METADATA_SIZE);
        ig_md.is_roce = false;
        transition parse_eth;
    }

    state parse_eth {
        pkt.extract(hdr.eth);
        transition select(hdr.eth.ether_type) {
            ETHERTYPE_IPV4 : parse_ipv4;
            default : accept;
        }
    }

    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            IP_PROTOCOLS_UDP : parse_udp;
            default : accept;
        }
    }

    state parse_udp {
        pkt.extract(hdr.udp);
        transition select(hdr.udp.dst_port) {
            UDP_PORT_ROCE : parse_bth;
            default : accept;
        }
    }

    state parse_bth {
        pkt.extract(hdr.bth);
        ig_md.is_roce = true;
        transition select(hdr.bth.opcode) {
            RDMA_OP_WRITE_FIRST: parse_write_reth;
            RDMA_OP_WRITE_MIDDLE: parse_payload;
            RDMA_OP_WRITE_LAST: parse_payload;
            RDMA_OP_WRITE_ONLY: parse_write_reth;
            RDMA_OP_READ_REQ: parse_read_reth;
            RDMA_OP_READ_RES_FIRST: parse_read_aeth;
            RDMA_OP_READ_RES_MIDDLE: parse_payload;
            RDMA_OP_READ_RES_LAST: parse_read_aeth;
            RDMA_OP_READ_RES_ONLY: parse_read_aeth;
            RDMA_OP_ACK: parse_ack_aeth;
            default : accept;
        }
    }

    state parse_write_reth {
        pkt.extract(hdr.reth);
        ig_md.bridge.has_reth = true;
        transition parse_payload;
    }

    state parse_read_aeth {
        pkt.extract(hdr.aeth);
        ig_md.bridge.has_aeth = true;
        transition parse_payload;
    }

    // for RDMA_OP_READ_REQ, no payload
    state parse_read_reth {
        pkt.extract(hdr.reth);
        ig_md.bridge.has_reth = true;
        transition accept;
    }

    state parse_payload {
        pkt.extract(hdr.payload);
        ig_md.bridge.has_payload = true;
        transition accept;
    }

    state parse_ack_aeth {
        pkt.extract(hdr.aeth);
        ig_md.bridge.has_aeth = true;
        transition accept;
    }
}
# 9 "a2a.p4" 2
# 1 "./a2a_ingress_control.p4" 1
control A2AIngress(
    inout a2a_headers_t hdr,
    inout a2a_ingress_metadata_t ig_md,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)
{
    // subcontrol modules instantiation
    DispatchIngress() dispatch_ctrl;
    CombineIngress() combine_ctrl;

    /*
     * Traffic Classification Table
     * Classify dispatch and combine traffic based on QP, IP, etc.
     */

    action set_a2a_traffic(CONN_PHASE conn_phase, CONN_SEMANTICS conn_semantics, bit<32> channel_id, bit<32> channel_class, bit<32> ing_rank_id, bit<32> root_rank_id) {
        ig_md.bridge.conn_phase = conn_phase;
        ig_md.bridge.conn_semantics = conn_semantics;
        ig_md.bridge.channel_id = channel_id;
        ig_md.bridge.ing_rank_id = ing_rank_id;
        ig_md.bridge.root_rank_id = root_rank_id;
        ig_md.channel_class = channel_class;
    }

    action set_unknown_traffic() {
        ig_md.bridge.conn_phase = CONN_PHASE.CONN_UNKNOWN;
    }

    // classification table: distinguish traffic type and connection info based on QPN and IPs
    table traffic_classify {
        key = {
            hdr.ipv4.src_addr : exact;
            hdr.ipv4.dst_addr : exact;
            hdr.bth.dst_qp : exact;
        }
        actions = {
            set_a2a_traffic;
            set_unknown_traffic;
        }
        size = 32768;
        default_action = set_unknown_traffic;
    }

    action set_bridge_ing_rank_id() {
        hdr.bridge.ing_rank_id = ig_md.bridge.ing_rank_id;
    }

    action set_bridge_has_reth() {
        hdr.bridge.has_reth = ig_md.bridge.has_reth;
    }

    action set_bridge_has_aeth() {
        hdr.bridge.has_aeth = ig_md.bridge.has_aeth;
    }

    action set_bridge_has_payload() {
        hdr.bridge.has_payload = ig_md.bridge.has_payload;
    }

    action set_bridge_conn_phase() {
        hdr.bridge.conn_phase = ig_md.bridge.conn_phase;
    }

    action set_bridge_conn_semantics() {
        hdr.bridge.conn_semantics = ig_md.bridge.conn_semantics;
    }

    action set_bridge_channel_id() {
        hdr.bridge.channel_id = ig_md.bridge.channel_id;
    }

    action set_bridge_bitmap() {
        hdr.bridge.bitmap = ig_md.bridge.bitmap;
    }

    action set_bridge_tx_loc_val() {
        hdr.bridge.tx_loc_val = ig_md.bridge.tx_loc_val;
    }

    action set_bridge_tx_offset_val() {
        hdr.bridge.tx_offset_val = ig_md.bridge.tx_offset_val;
    }

    action set_bridge_clear_offset() {
        hdr.bridge.clear_offset = ig_md.bridge.clear_offset;
    }

    action set_bridge_is_loopback() {
        hdr.bridge.is_loopback = ig_md.bridge.is_loopback;
    }

    action set_bridge_root_rank_id_lo() {
        hdr.bridge.root_rank_id[15:0] = ig_md.bridge.root_rank_id[15:0];
    }

    action set_bridge_root_rank_id_hi() {
        hdr.bridge.root_rank_id[31:16] = ig_md.bridge.root_rank_id[31:16];
    }

    action set_bridge_next_token_addr_hi() {
        hdr.bridge.next_token_addr[63:32] = ig_md.bridge.next_token_addr[63:32];
    }

    action set_bridge_next_token_addr_lo() {
        hdr.bridge.next_token_addr[31:0] = ig_md.bridge.next_token_addr[31:0];
    }



    apply {
        // Process only RoCE packets
        if (!ig_md.is_roce) {
            ig_dprsr_md.drop_ctl = 1;
            return;
        }

        ig_md.psn = hdr.bth.psn;
        ig_md.psn[0:0] = 0;
        if(hdr.aeth.isValid()){
            ig_md.msn = hdr.aeth.msn & 32w0xFFFFFF00;
            ig_md.syndrome = hdr.aeth.msn & 32w0x000000FF;
        }
        // Traffic classification
        traffic_classify.apply();

        // Invoke corresponding processing logic based on traffic type
        if (ig_md.bridge.conn_phase == CONN_PHASE.CONN_DISPATCH) {
            dispatch_ctrl.apply(hdr, ig_md, ig_intr_md, ig_dprsr_md, ig_tm_md);
        } else if (ig_md.bridge.conn_phase == CONN_PHASE.CONN_COMBINE) {
            combine_ctrl.apply(hdr, ig_md, ig_intr_md, ig_dprsr_md, ig_tm_md);
        } else {
            // drop unknown traffic
            ig_dprsr_md.drop_ctl = 1;
        }

        hdr.bridge.setValid();
        set_bridge_ing_rank_id();
        set_bridge_has_reth();
        set_bridge_has_aeth();
        set_bridge_has_payload();
        set_bridge_conn_phase();
        set_bridge_conn_semantics();
        set_bridge_channel_id();
        set_bridge_bitmap();
        set_bridge_tx_loc_val();
        set_bridge_tx_offset_val();
        set_bridge_clear_offset();
        set_bridge_is_loopback();
        set_bridge_root_rank_id_hi();
        set_bridge_root_rank_id_lo();
        set_bridge_next_token_addr_hi();
        set_bridge_next_token_addr_lo();
    }
}

control A2AIngressDeparser(
        packet_out pkt,
        inout a2a_headers_t hdr,
        in a2a_ingress_metadata_t ig_md,
        in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md) {


    apply {
        pkt.emit(hdr);
    }
}
# 10 "a2a.p4" 2
# 1 "./a2a_egress_parser.p4" 1
parser A2AEgressParser(
    packet_in pkt,
    out a2a_headers_t hdr,
    out a2a_egress_metadata_t eg_md,
    out egress_intrinsic_metadata_t eg_intr_md)
{
    state start {

        pkt.extract(eg_intr_md);
        pkt.extract(hdr.bridge);
        pkt.extract(hdr.eth);
        pkt.extract(hdr.ipv4);
        pkt.extract(hdr.udp);
        pkt.extract(hdr.bth);

        transition select(hdr.bridge.has_aeth) {
            true : parse_aeth;
            false : check_reth;
        }
    }

    state parse_aeth {
        pkt.extract(hdr.aeth);
        transition check_reth;
    }

    state check_reth {
        transition select(hdr.bridge.has_reth) {
            true : parse_reth;
            false : check_payload;
        }
    }

    state parse_reth {
        pkt.extract(hdr.reth);
        transition check_payload;
    }

    state check_payload {
        transition select(hdr.bridge.has_payload) {
            true : parse_payload;
            false : accept;
        }
    }

    state parse_payload {
        pkt.extract(hdr.payload_first_word);
        transition accept;
    }
}
# 11 "a2a.p4" 2
# 1 "./a2a_egress_control.p4" 1
control A2AEgress(
    inout a2a_headers_t hdr,
    inout a2a_egress_metadata_t eg_md,
    in egress_intrinsic_metadata_t eg_intr_md,
    in egress_intrinsic_metadata_from_parser_t eg_prsr_md,
    inout egress_intrinsic_metadata_for_deparser_t eg_dprsr_md,
    inout egress_intrinsic_metadata_for_output_port_t eg_oport_md)
{
    DispatchEgress() dispatch_egress;
    CombineEgress() combine_egress;

    apply {
        // eg_md.bridge.ing_rank_id     = (bit<32>)hdr.bridge.ing_rank_id;
        // eg_md.bridge.has_reth        = hdr.bridge.has_reth;
        // eg_md.bridge.has_aeth        = hdr.bridge.has_aeth;
        // eg_md.bridge.has_payload     = hdr.bridge.has_payload;
        // eg_md.bridge.conn_phase      = hdr.bridge.conn_phase;
        // eg_md.bridge.conn_semantics  = hdr.bridge.conn_semantics;
        // eg_md.bridge.channel_id      = hdr.bridge.channel_id;
        // eg_md.bridge.bitmap          = hdr.bridge.bitmap;
        // eg_md.bridge.tx_loc_val      = (bit<32>)hdr.bridge.tx_loc_val;
        // eg_md.bridge.tx_offset_val   = (bit<32>)hdr.bridge.tx_offset_val;
        // eg_md.bridge.clear_offset    = (bit<32>)hdr.bridge.clear_offset;
        // eg_md.bridge.is_loopback     = hdr.bridge.is_loopback;
        // eg_md.bridge.root_rank_id    = (bit<32>)hdr.bridge.root_rank_id;
        // eg_md.bridge.next_token_addr = hdr.bridge.next_token_addr;

        eg_md.psn = hdr.bth.psn;

        if (eg_md.bridge.conn_phase == CONN_PHASE.CONN_DISPATCH) {
            dispatch_egress.apply(hdr, eg_md, eg_intr_md, eg_dprsr_md);
        } else if (eg_md.bridge.conn_phase == CONN_PHASE.CONN_COMBINE) {
            combine_egress.apply(hdr, eg_md, eg_intr_md, eg_dprsr_md);
        }
    }
}

control A2AEgressDeparser(
        packet_out pkt,
        inout a2a_headers_t hdr,
        in a2a_egress_metadata_t eg_md,
        in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md) {
    apply {
        pkt.emit(hdr);
    }
}
# 12 "a2a.p4" 2

Pipeline(
    A2AIngressParser(),
    A2AIngress(),
    A2AIngressDeparser(),
    A2AEgressParser(),
    A2AEgress(),
    A2AEgressDeparser()
) pipe;

Switch(pipe) main;
